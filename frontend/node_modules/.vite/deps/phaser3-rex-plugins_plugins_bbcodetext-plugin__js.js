import "./chunk-RSJERJUL.js";

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/render/WebGLRenderer.js
var Utils = Phaser.Renderer.WebGL.Utils;
var WebGLRenderer = function(renderer, src, camera, parentMatrix) {
  if (src.width === 0 || src.height === 0) {
    return;
  }
  camera.addToRenderList(src);
  var frame = src.frame;
  var width = frame.width;
  var height = frame.height;
  var getTint = Utils.getTintAppendFloatAlpha;
  var pipeline = renderer.pipelines.set(src.pipeline, src);
  var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
  renderer.pipelines.preBatch(src);
  pipeline.batchTexture(
    src,
    frame.glTexture,
    width,
    height,
    src.x,
    src.y,
    width / src.style.resolution,
    height / src.style.resolution,
    src.scaleX,
    src.scaleY,
    src.rotation,
    src.flipX,
    src.flipY,
    src.scrollFactorX,
    src.scrollFactorY,
    src.displayOriginX,
    src.displayOriginY,
    0,
    0,
    width,
    height,
    getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
    getTint(src.tintTopRight, camera.alpha * src._alphaTR),
    getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
    getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
    src.tintFill,
    0,
    0,
    camera,
    parentMatrix,
    false,
    textureUnit
  );
  renderer.pipelines.postBatch(src);
};
var WebGLRenderer_default = WebGLRenderer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/render/CanvasRenderer.js
var CanvasRenderer = function(renderer, src, camera, parentMatrix) {
  if (src.width === 0 || src.height === 0) {
    return;
  }
  camera.addToRenderList(src);
  renderer.batchSprite(src, src.frame, camera, parentMatrix);
};
var CanvasRenderer_default = CanvasRenderer;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/render/Render.js
var Render_default = {
  renderWebGL: WebGLRenderer_default,
  renderCanvas: CanvasRenderer_default
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/MeasureTextMargins.js
var CanvasPool = Phaser.Display.Canvas.CanvasPool;
var MeasureTextMargins = function(textStyle, testString, out) {
  if (out === void 0) {
    out = {};
  }
  var canvas = CanvasPool.create(this);
  var context = canvas.getContext("2d", { willReadFrequently: true });
  textStyle.syncFont(canvas, context);
  var metrics = context.measureText(testString);
  var width = Math.ceil(metrics.width * textStyle.baselineX);
  var baseline = width;
  var height = 2 * baseline;
  baseline = baseline * textStyle.baselineY | 0;
  canvas.width = width;
  canvas.height = height;
  context.fillStyle = "#f00";
  context.fillRect(0, 0, width, height);
  context.font = textStyle._font;
  context.textBaseline = "alphabetic";
  context.fillStyle = "#000";
  context.fillText(textStyle.testString, 0, baseline);
  out.left = 0;
  if (width === 0 || height === 0 || !context.getImageData(0, 0, width, height)) {
    CanvasPool.remove(canvas);
    return out;
  }
  var imagedata = context.getImageData(0, 0, width, height).data;
  var stop = false;
  for (var x = 0; x < width; x++) {
    for (var y = 0; y < height; y++) {
      var idx = (y * width + x) * 4;
      if (imagedata[idx] !== 255) {
        out.left = x;
        stop = true;
        break;
      }
    }
    if (stop) {
      break;
    }
  }
  CanvasPool.remove(canvas);
  return out;
};
var MeasureTextMargins_default = MeasureTextMargins;

// node_modules/phaser3-rex-plugins/plugins/utils/system/CheckP3Version.js
var MinVersion = 60;
var IsChecked = false;
var CheckP3Version = function(minVersion) {
  if (IsChecked) {
    return;
  }
  if (minVersion === void 0) {
    minVersion = MinVersion;
  }
  var currentVersion = parseInt(Phaser.VERSION.match(/\.(\d+)\./)[1]);
  if (currentVersion < minVersion) {
    console.error(`Minimum supported version : 3.${minVersion}`);
  }
  IsChecked = true;
};
var CheckP3Version_default = CheckP3Version;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/TextBase.js
CheckP3Version_default();
var GameObject = Phaser.GameObjects.GameObject;
var TextBase = class extends GameObject {
  setStyle(style) {
    return this.style.setStyle(style);
  }
  setFont(font) {
    return this.style.setFont(font);
  }
  setFontFamily(family) {
    return this.style.setFontFamily(family);
  }
  setFontSize(size) {
    return this.style.setFontSize(size);
  }
  setFontStyle(style) {
    return this.style.setFontStyle(style);
  }
  setTestString(string) {
    return this.style.setTestString(string);
  }
  setFixedSize(width, height) {
    return this.style.setFixedSize(width, height);
  }
  setBackgroundColor(color, color2, isHorizontalGradient) {
    return this.style.setBackgroundColor(color, color2, isHorizontalGradient);
  }
  setBackgroundStrokeColor(color, lineWidth) {
    return this.style.setBackgroundStrokeColor(color, lineWidth);
  }
  setBackgroundCornerRadius(radius, iteration) {
    return this.style.setBackgroundCornerRadius(radius, iteration);
  }
  setFill(color) {
    return this.style.setFill(color);
  }
  setColor(color) {
    return this.style.setColor(color);
  }
  setStroke(color, thickness) {
    return this.style.setStroke(color, thickness);
  }
  setShadow(x, y, color, blur, shadowStroke, shadowFill) {
    return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
  }
  setShadowOffset(x, y) {
    return this.style.setShadowOffset(x, y);
  }
  setShadowColor(color) {
    return this.style.setShadowColor(color);
  }
  setShadowBlur(blur) {
    return this.style.setShadowBlur(blur);
  }
  setShadowStroke(enabled) {
    return this.style.setShadowStroke(enabled);
  }
  setShadowFill(enabled) {
    return this.style.setShadowFill(enabled);
  }
  setWrapMode(mode) {
    return this.style.setWrapMode(mode);
  }
  setWrapWidth(width) {
    return this.style.setWrapWidth(width);
  }
  setWordWrapWidth(width) {
    return this.style.setWrapWidth(width);
  }
  setAlign(align) {
    return this.style.setHAlign(align);
  }
  setHAlign(align) {
    return this.style.setHAlign(align);
  }
  setVAlign(align) {
    return this.style.setVAlign(align);
  }
  setLineSpacing(value) {
    this.lineSpacing = value;
    this.updateText(false);
    return this;
  }
  setXOffset(value) {
    return this.style.setXOffset(value);
  }
  setMaxLines(max) {
    return this.style.setMaxLines(max);
  }
  setResolution(value) {
    return this.style.setResolution(value);
  }
  getTextMetrics() {
    return this.style.getTextMetrics();
  }
  setTextMetrics(metrics, font) {
    return this.style.setTextMetrics(metrics, font);
  }
  measureTextMargins(testString, out) {
    return MeasureTextMargins_default(this.style, testString, out);
  }
};
var Components2 = Phaser.GameObjects.Components;
Phaser.Class.mixin(
  TextBase,
  [
    Components2.Alpha,
    Components2.BlendMode,
    Components2.ComputedSize,
    Components2.Crop,
    Components2.Depth,
    Components2.Flip,
    Components2.GetBounds,
    Components2.Mask,
    Components2.Origin,
    Components2.Pipeline,
    Components2.PostPipeline,
    Components2.ScrollFactor,
    Components2.Tint,
    Components2.Transform,
    Components2.Visible,
    Render_default
  ]
);
var TextBase_default = TextBase;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/GetStyle.js
var Pad = Phaser.Utils.String.Pad;
var GetStyle = function(style, canvas, context) {
  if (style == null) {
    return style;
  }
  switch (typeof style) {
    case "string":
      return style;
    case "number":
      return `#${Pad(Math.floor(style).toString(16), 6, "0", 1)}`;
    case "function":
      return style(canvas, context);
    case "object":
      if (style.hasOwnProperty("r")) {
        if (style.hasOwnProperty("a")) {
          return `rgba(${style.r},${style.g},${style.b},${style.a})`;
        } else {
          return `rgb(${style.r},${style.g},${style.b})`;
        }
      } else if (style.hasOwnProperty("h")) {
        if (style.hasOwnProperty("a")) {
          return `hsla(${style.h},${style.s},${style.l},${style.a})`;
        } else {
          return `hsl(${style.h},${style.s},${style.l})`;
        }
      } else {
        return style;
      }
    default:
      return style;
  }
};
var GetStyle_default = GetStyle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/PropertyMap.js
var PropertyMap = {
  backgroundColor: ["backgroundColor", null, GetStyle_default],
  backgroundColor2: ["backgroundColor2", null, GetStyle_default],
  backgroundHorizontalGradient: ["backgroundHorizontalGradient", true, null],
  backgroundStrokeColor: ["backgroundStrokeColor", null, GetStyle_default],
  backgroundStrokeLineWidth: ["backgroundStrokeLineWidth", 2, null],
  backgroundCornerRadius: ["backgroundCornerRadius", 0, null],
  backgroundCornerIteration: ["backgroundCornerIteration", null, null],
  fontFamily: ["fontFamily", "Courier", null],
  fontSize: ["fontSize", "16px", null],
  fontStyle: ["fontStyle", "", null],
  color: ["color", "#fff", GetStyle_default],
  stroke: ["stroke", "#fff", GetStyle_default],
  strokeThickness: ["strokeThickness", 0, null],
  shadowOffsetX: ["shadow.offsetX", 0, null],
  shadowOffsetY: ["shadow.offsetY", 0, null],
  shadowColor: ["shadow.color", "#000", GetStyle_default],
  shadowBlur: ["shadow.blur", 0, null],
  shadowStroke: ["shadow.stroke", false, null],
  shadowFill: ["shadow.fill", false, null],
  underlineColor: ["underline.color", "#000", GetStyle_default],
  underlineThickness: ["underline.thickness", 0, null],
  underlineOffset: ["underline.offset", 0, null],
  strikethroughColor: ["strikethrough.color", "#000", GetStyle_default],
  strikethroughThickness: ["strikethrough.thickness", 0, null],
  strikethroughOffset: ["strikethrough.offset", 0, null],
  halign: ["halign", "left", null],
  valign: ["valign", "top", null],
  maxLines: ["maxLines", 0, null],
  fixedWidth: ["fixedWidth", 0, null],
  fixedHeight: ["fixedHeight", 0, null],
  resolution: ["resolution", 0, null],
  lineSpacing: ["lineSpacing", 0, null],
  xOffset: ["xOffset", 0, null],
  rtl: ["rtl", false, null],
  testString: ["testString", "|M\xC3\u2030qgy", null],
  baselineX: ["baselineX", 1.2, null],
  baselineY: ["baselineY", 1.4, null],
  wrapMode: ["wrap.mode", 0, null],
  wrapWidth: ["wrap.width", 0, null],
  wrapCallback: ["wrap.callback", null],
  wrapCallbackScope: ["wrap.callbackScope", null]
};
var PropertyMap_default = PropertyMap;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/MeasureText.js
var CanvasPool2 = Phaser.Display.Canvas.CanvasPool;
var MeasureText = function(textStyle) {
  var canvas = CanvasPool2.create(this);
  var context = canvas.getContext("2d", { willReadFrequently: true });
  textStyle.syncFont(canvas, context);
  var metrics = context.measureText(textStyle.testString);
  if ("actualBoundingBoxAscent" in metrics) {
    var ascent = metrics.actualBoundingBoxAscent;
    var descent = metrics.actualBoundingBoxDescent;
    var output = {
      ascent,
      descent,
      fontSize: ascent + descent
    };
    CanvasPool2.remove(canvas);
    return output;
  }
  var width = Math.ceil(metrics.width * textStyle.baselineX);
  var baseline = width;
  var height = 2 * baseline;
  baseline = baseline * textStyle.baselineY | 0;
  canvas.width = width;
  canvas.height = height;
  context.fillStyle = "#f00";
  context.fillRect(0, 0, width, height);
  context.font = textStyle._font;
  context.textBaseline = "alphabetic";
  context.fillStyle = "#000";
  context.fillText(textStyle.testString, 0, baseline);
  var output = {
    ascent: 0,
    descent: 0,
    fontSize: 0
  };
  if (!context.getImageData(0, 0, width, height)) {
    output.ascent = baseline;
    output.descent = baseline + 6;
    output.fontSize = output.ascent + output.descent;
    CanvasPool2.remove(canvas);
    return output;
  }
  var imagedata = context.getImageData(0, 0, width, height).data;
  var pixels = imagedata.length;
  var line = width * 4;
  var i;
  var j;
  var idx = 0;
  var stop = false;
  for (i = 0; i < baseline; i++) {
    for (j = 0; j < line; j += 4) {
      if (imagedata[idx + j] !== 255) {
        stop = true;
        break;
      }
    }
    if (!stop) {
      idx += line;
    } else {
      break;
    }
  }
  output.ascent = baseline - i;
  idx = pixels - line;
  stop = false;
  for (i = height; i > baseline; i--) {
    for (j = 0; j < line; j += 4) {
      if (imagedata[idx + j] !== 255) {
        stop = true;
        break;
      }
    }
    if (!stop) {
      idx -= line;
    } else {
      break;
    }
  }
  output.descent = i - baseline;
  output.fontSize = output.ascent + output.descent;
  CanvasPool2.remove(canvas);
  return output;
};
var MeasureText_default = MeasureText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/const.js
var CONST = {
  NO_NEWLINE: 0,
  RAW_NEWLINE: 1,
  WRAPPED_NEWLINE: 2,
  NO_WRAP: 0,
  WORD_WRAP: 1,
  CHAR_WRAP: 2,
  MIX_WRAP: 3,
  SPLITREGEXP: /(?:\r\n|\r|\n)/
};
var const_default = CONST;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/WrapModes.js
var WRAPMODE = {
  none: const_default.NO_WRAP,
  word: const_default.WORD_WRAP,
  char: const_default.CHAR_WRAP,
  character: const_default.CHAR_WRAP,
  mix: const_default.MIX_WRAP
};
var WrapModes_default = WRAPMODE;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/textbase/textstyle/TextStyle.js
var GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
var GetValue = Phaser.Utils.Objects.GetValue;
var TextStyle = class {
  constructor(text, style, propertyMap) {
    this.parent = text;
    if (propertyMap === void 0) {
      propertyMap = PropertyMap_default;
    }
    this.propertyMap = propertyMap;
    this.backgroundColor;
    this.backgroundColor2;
    this.backgroundHorizontalGradient;
    this.backgroundStrokeColor;
    this.backgroundStrokeLineWidth;
    this.backgroundCornerRadius;
    this.backgroundCornerIteration;
    this.fontFamily;
    this.fontSize;
    this.fontStyle;
    this.color;
    this.stroke;
    this.strokeThickness;
    this.shadowOffsetX;
    this.shadowOffsetY;
    this.shadowColor;
    this.shadowBlur;
    this.shadowStroke;
    this.shadowFill;
    this.underlineColor;
    this.underlineThickness;
    this.underlineOffset;
    this.strikethroughColor;
    this.strikethroughThickness;
    this.strikethroughOffset;
    this.halign;
    this.valign;
    this.maxLines;
    this.fixedWidth;
    this.fixedHeight;
    this.resolution;
    this.xOffset;
    this.rtl;
    this.testString;
    this.baselineX;
    this.baselineY;
    this.wrapMode;
    this.wrapWidth;
    this.wrapCallback;
    this.wrapCallbackScope;
    this._font;
    this.setStyle(style, false, true);
  }
  get isWrapFitMode() {
    return this.fixedWidth > 0 && this.wrapMode !== const_default.NO_WRAP && this.wrapWidth === 0;
  }
  setStyle(style, updateText, setDefaults) {
    if (updateText === void 0) {
      updateText = true;
    }
    if (setDefaults === void 0) {
      setDefaults = false;
    }
    if (style && style.hasOwnProperty("wordWrap")) {
      var wordWrap = style.wordWrap;
      if (wordWrap.hasOwnProperty("width")) {
        style.wrap = {
          mode: "word",
          width: wordWrap.width
        };
      }
    }
    if (style && style.hasOwnProperty("wrap")) {
      var wrap = style.wrap;
      if (wrap.hasOwnProperty("mode")) {
        var mode = wrap.mode;
        if (typeof mode === "string") {
          wrap.mode = WrapModes_default[mode];
        }
      } else {
        if (wrap.hasOwnProperty("width")) {
          wrap.mode = 1;
        }
      }
    }
    if (style && style.rtl && setDefaults && !style.hasOwnProperty("halign")) {
      style.halign = "right";
    }
    if (style && style.hasOwnProperty("fontSize") && typeof style.fontSize === "number") {
      style.fontSize = style.fontSize.toString() + "px";
    }
    var propertyMap = this.propertyMap;
    for (var key in propertyMap) {
      var prop = propertyMap[key];
      var objKey = prop[0];
      var defaultValue = setDefaults ? prop[1] : this[key];
      var postCallback = prop[2];
      if (key === "wrapCallback" || key === "wrapCallbackScope") {
        this[key] = GetValue(style, objKey, defaultValue);
      } else {
        var value = GetAdvancedValue(style, objKey, defaultValue);
        if (postCallback) {
          value = postCallback(value);
        }
        this[key] = value;
      }
    }
    var font = GetValue(style, "font", null);
    if (font === null) {
      this._font = this.fontStyle + " " + this.fontSize + " " + this.fontFamily;
    } else {
      this._font = font;
    }
    var fill = GetValue(style, "fill", null);
    if (fill !== null) {
      this.color = GetStyle_default(fill);
    }
    var metrics = GetValue(style, "metrics", false);
    if (metrics) {
      this.metrics = {
        ascent: GetValue(metrics, "ascent", 0),
        descent: GetValue(metrics, "descent", 0),
        fontSize: GetValue(metrics, "fontSize", 0)
      };
    } else if (updateText || !this.metrics) {
      this.metrics = MeasureText_default(this);
    }
    if (updateText) {
      return this.parent.updateText();
    } else {
      return this.parent;
    }
  }
  syncFont(canvas, context) {
    context.font = this._font;
  }
  syncStyle(canvas, context) {
    context.textBaseline = "alphabetic";
    context.fillStyle = this.color;
    context.strokeStyle = this.stroke;
    context.lineWidth = this.strokeThickness;
    context.lineCap = "round";
    context.lineJoin = "round";
  }
  syncShadow(context, enabled) {
    if (enabled) {
      context.shadowOffsetX = this.shadowOffsetX;
      context.shadowOffsetY = this.shadowOffsetY;
      context.shadowColor = this.shadowColor;
      context.shadowBlur = this.shadowBlur;
    } else {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowColor = 0;
      context.shadowBlur = 0;
    }
  }
  update(recalculateMetrics) {
    if (recalculateMetrics) {
      this._font = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();
      this.metrics = MeasureText_default(this);
    }
    return this.parent.updateText(recalculateMetrics);
  }
  buildFont() {
    var newFont = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();
    if (newFont !== this._font) {
      this._font = newFont;
    }
    return this;
  }
  setFont(font) {
    if (typeof font === "string") {
      this.fontFamily = font;
      this.fontSize = "";
      this.fontStyle = "";
    } else {
      this.fontFamily = GetValue(font, "fontFamily", "Courier");
      this.fontSize = GetValue(font, "fontSize", "16px");
      this.fontStyle = GetValue(font, "fontStyle", "");
    }
    return this.update(true);
  }
  setFontFamily(family) {
    this.fontFamily = family;
    return this.update(true);
  }
  setFontStyle(style) {
    this.fontStyle = style;
    return this.update(true);
  }
  setFontSize(size) {
    if (typeof size === "number") {
      size = size.toString() + "px";
    }
    this.fontSize = size;
    return this.update(true);
  }
  setTestString(string) {
    this.testString = string;
    return this.update(true);
  }
  setFixedSize(width, height) {
    this.fixedWidth = width;
    this.fixedHeight = height;
    if (width) {
      this.parent.width = width;
    }
    if (height) {
      this.parent.height = height;
    }
    return this.update(this.isWrapFitMode);
  }
  setResolution(value) {
    this.resolution = value;
    return this.update(false);
  }
  setXOffset(value) {
    this.xOffset = value;
    return this.update(false);
  }
  setBackgroundColor(color, color2, isHorizontalGradient) {
    if (isHorizontalGradient === void 0) {
      isHorizontalGradient = true;
    }
    this.backgroundColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.backgroundColor2 = GetStyle_default(color2, this.parent.canvas, this.parent.context);
    this.backgroundHorizontalGradient = isHorizontalGradient;
    return this.update(false);
  }
  setBackgroundStrokeColor(color, lineWidth) {
    this.backgroundStrokeColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.backgroundStrokeLineWidth = lineWidth;
    return this.update(false);
  }
  setBackgroundCornerRadius(radius, iteration) {
    this.backgroundCornerRadius = radius;
    this.backgroundCornerIteration = iteration;
    return this.update(false);
  }
  setFill(color) {
    this.color = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setColor(color) {
    this.color = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setStroke(color, thickness) {
    if (color === void 0) {
      this.strokeThickness = 0;
    } else {
      if (thickness === void 0) {
        thickness = this.strokeThickness;
      }
      this.stroke = GetStyle_default(color, this.parent.canvas, this.parent.context);
      this.strokeThickness = thickness;
    }
    return this.update(true);
  }
  setShadow(x, y, color, blur, shadowStroke, shadowFill) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (color === void 0) {
      color = "#000";
    }
    if (blur === void 0) {
      blur = 0;
    }
    if (shadowStroke === void 0) {
      shadowStroke = false;
    }
    if (shadowFill === void 0) {
      shadowFill = true;
    }
    this.shadowOffsetX = x;
    this.shadowOffsetY = y;
    this.shadowColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.shadowBlur = blur;
    this.shadowStroke = shadowStroke;
    this.shadowFill = shadowFill;
    return this.update(false);
  }
  setShadowOffset(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = x;
    }
    this.shadowOffsetX = x;
    this.shadowOffsetY = y;
    return this.update(false);
  }
  setShadowColor(color) {
    if (color === void 0) {
      color = "#000";
    }
    this.shadowColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setShadowBlur(blur) {
    if (blur === void 0) {
      blur = 0;
    }
    this.shadowBlur = blur;
    return this.update(false);
  }
  setShadowStroke(enabled) {
    this.shadowStroke = enabled;
    return this.update(false);
  }
  setShadowFill(enabled) {
    this.shadowFill = enabled;
    return this.update(false);
  }
  setUnderline(color, thickness, offset) {
    if (color === void 0) {
      color = "#000";
    }
    if (thickness === void 0) {
      thickness = 0;
    }
    if (offset === void 0) {
      offset = 0;
    }
    this.underlineColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.underlineThickness = thickness;
    this.underlineOffset = offset;
    return this.update(false);
  }
  setUnderlineColor(color) {
    if (color === void 0) {
      color = "#000";
    }
    this.underlineColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setUnderlineThickness(thickness) {
    if (thickness === void 0) {
      thickness = 0;
    }
    this.underlineThickness = thickness;
    return this.update(false);
  }
  setUnderlineOffset(offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.underlineOffset = offset;
    return this.update(false);
  }
  setStrikethrough(color, thickness, offset) {
    if (color === void 0) {
      color = "#000";
    }
    if (thickness === void 0) {
      thickness = 0;
    }
    if (offset === void 0) {
      offset = 0;
    }
    this.strikethroughColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    this.strikethroughThickness = thickness;
    this.strikethroughOffset = offset;
    return this.update(false);
  }
  setStrikethroughColor(color) {
    if (color === void 0) {
      color = "#000";
    }
    this.strikethroughColor = GetStyle_default(color, this.parent.canvas, this.parent.context);
    return this.update(false);
  }
  setStrikethroughThickness(thickness) {
    if (thickness === void 0) {
      thickness = 0;
    }
    this.strikethroughThickness = thickness;
    return this.update(false);
  }
  setStrikethroughOffset(offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.strikethroughOffset = offset;
    return this.update(false);
  }
  setWrapMode(mode) {
    if (typeof mode === "string") {
      mode = WrapModes_default[mode.toLowerCase()] || 0;
    }
    this.wrapMode = mode;
    return this.update(true);
  }
  setWrapWidth(width) {
    this.wrapWidth = width;
    return this.update(false);
  }
  setAlign(halign, valign) {
    if (halign === void 0) {
      halign = "left";
    }
    if (valign === void 0) {
      valign = "top";
    }
    this.halign = halign;
    this.valign = valign;
    return this.update(false);
  }
  setHAlign(halign) {
    if (halign === void 0) {
      halign = "left";
    }
    this.halign = halign;
    return this.update(false);
  }
  setVAlign(valign) {
    if (valign === void 0) {
      valign = "top";
    }
    this.valign = valign;
    return this.update(false);
  }
  setMaxLines(max) {
    if (max === void 0) {
      max = 0;
    }
    this.maxLines = max;
    return this.update(false);
  }
  getTextMetrics() {
    var metrics = this.metrics;
    return {
      ascent: metrics.ascent,
      descent: metrics.descent,
      fontSize: metrics.fontSize
    };
  }
  setTextMetrics(metrics, font) {
    this.metrics.ascent = metrics.ascent;
    this.metrics.descent = metrics.descent;
    this.metrics.fontSize = metrics.fontSize;
    if (font) {
      if (typeof font === "string") {
        this.fontFamily = font;
        this.fontSize = "";
        this.fontStyle = "";
      } else {
        this.fontFamily = GetValue(font, "fontFamily", this.fontFamily);
        this.fontSize = GetValue(font, "fontSize", this.fontSize);
        this.fontStyle = GetValue(font, "fontStyle", this.fontStyle);
      }
    }
    return this.parent.updateText(true);
  }
  get lineHeight() {
    return this.metrics.fontSize + this.strokeThickness + this.parent.lineSpacing;
  }
  toJSON() {
    var output = {};
    var propertyMap = this.propertyMap;
    for (var key in propertyMap) {
      output[key] = this[key];
    }
    output.metrics = this.getTextMetrics();
    return output;
  }
  destroy() {
    this.parent = void 0;
  }
};
var TextStyle_default = TextStyle;

// node_modules/phaser3-rex-plugins/plugins/geom/roundrectangle/RoundRectangle.js
var GetValue2 = Phaser.Utils.Objects.GetValue;
var RoundRectangle = class {
  constructor(x, y, width, height, radiusConfig) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = x;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    if (radiusConfig === void 0) {
      radiusConfig = 0;
    }
    this.cornerRadius = {};
    this._width = 0;
    this._height = 0;
    this.setTo(x, y, width, height, radiusConfig);
  }
  setTo(x, y, width, height, radiusConfig) {
    this.setPosition(x, y);
    this.setRadius(radiusConfig);
    this.setSize(width, height);
    return this;
  }
  setPosition(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setRadius(value) {
    if (value === void 0) {
      value = 0;
    }
    this.radius = value;
    return this;
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  get minWidth() {
    var radius = this.cornerRadius;
    return Math.max(radius.tl.x + radius.tr.x, radius.bl.x + radius.br.x);
  }
  get minHeight() {
    var radius = this.cornerRadius;
    return Math.max(radius.tl.y + radius.bl.y, radius.tr.y + radius.br.y);
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value == null) {
      value = 0;
    }
    this._width = Math.max(value, this.minWidth);
  }
  get height() {
    return this._height;
  }
  set height(value) {
    if (value == null) {
      value = 0;
    }
    this._height = Math.max(value, this.minHeight);
  }
  get radius() {
    var radius = this.cornerRadius;
    return Math.max(
      radius.tl.x,
      radius.tl.y,
      radius.tr.x,
      radius.tr.y,
      radius.bl.x,
      radius.bl.y,
      radius.br.x,
      radius.br.y
    );
  }
  set radius(value) {
    var defaultRadiusX, defaultRadiusY;
    if (typeof value === "number") {
      defaultRadiusX = value;
      defaultRadiusY = value;
    } else {
      defaultRadiusX = GetValue2(value, "x", 0);
      defaultRadiusY = GetValue2(value, "y", 0);
    }
    var radius = this.cornerRadius;
    radius.tl = GetRadius(GetValue2(value, "tl", void 0), defaultRadiusX, defaultRadiusY);
    radius.tr = GetRadius(GetValue2(value, "tr", void 0), defaultRadiusX, defaultRadiusY);
    radius.bl = GetRadius(GetValue2(value, "bl", void 0), defaultRadiusX, defaultRadiusY);
    radius.br = GetRadius(GetValue2(value, "br", void 0), defaultRadiusX, defaultRadiusY);
  }
  get radiusTL() {
    var radius = this.cornerRadius.tl;
    return Math.max(radius.x, radius.y);
  }
  set radiusTL(value) {
    SetRadius(this.cornerRadius.tl, value);
  }
  get radiusTR() {
    var radius = this.cornerRadius.tr;
    return Math.max(radius.x, radius.y);
  }
  set radiusTR(value) {
    SetRadius(this.cornerRadius.tr, value);
  }
  get radiusBL() {
    var radius = this.cornerRadius.bl;
    return Math.max(radius.x, radius.y);
  }
  set radiusBL(value) {
    SetRadius(this.cornerRadius.bl, value);
  }
  get radiusBR() {
    var radius = this.cornerRadius.br;
    return Math.max(radius.x, radius.y);
  }
  set radiusBR(value) {
    SetRadius(this.cornerRadius.br, value);
  }
};
var GetRadius = function(radius, defaultRadiusX, defaultRadiusY) {
  if (radius === void 0) {
    radius = {
      x: defaultRadiusX,
      y: defaultRadiusY
    };
  } else if (typeof radius === "number") {
    radius = {
      x: radius,
      y: radius
    };
  }
  SetConvex(radius);
  return radius;
};
var SetRadius = function(radius, value) {
  if (typeof value === "number") {
    radius.x = value;
    radius.y = value;
  } else {
    radius.x = GetValue2(value, "x", 0);
    radius.y = GetValue2(value, "y", 0);
  }
  SetConvex(radius);
};
var SetConvex = function(radius) {
  radius.convex = radius.x >= 0 || radius.y >= 0;
  radius.x = Math.abs(radius.x);
  radius.y = Math.abs(radius.y);
};
var RoundRectangle_default = RoundRectangle;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/AddRoundRectanglePath.js
var DegToRad = Phaser.Math.DegToRad;
var AddRoundRectanglePath = function(context, x, y, width, height, radiusConfig, iteration) {
  var geom = new RoundRectangle_default(x, y, width, height, radiusConfig), minWidth = geom.minWidth, minHeight = geom.minHeight, scaleRX = width >= minWidth ? 1 : width / minWidth, scaleRY = height >= minHeight ? 1 : height / minHeight;
  var cornerRadius = geom.cornerRadius;
  var radius, radiusX, radiusY, centerX, centerY;
  var startX, startY;
  context.save();
  context.beginPath();
  context.translate(x, y);
  radius = cornerRadius.tl;
  if (IsArcCorner(radius)) {
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    if (IsConvexArc(radius)) {
      centerX = radiusX;
      centerY = radiusY;
      ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 270, false, iteration);
    } else {
      centerX = 0;
      centerY = 0;
      ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 0, true, iteration);
    }
    startX = 0;
    startY = radiusY;
  } else {
    context.lineTo(0, 0);
    startX = 0;
    startY = 0;
  }
  radius = cornerRadius.tr;
  if (IsArcCorner(radius)) {
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    if (IsConvexArc(radius)) {
      centerX = width - radiusX;
      centerY = radiusY;
      ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 360, false, iteration);
    } else {
      centerX = width;
      centerY = 0;
      ArcTo(context, centerX, centerY, radiusX, radiusY, 180, 90, true, iteration);
    }
  } else {
    context.lineTo(width, 0);
  }
  radius = cornerRadius.br;
  if (IsArcCorner(radius)) {
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    if (IsConvexArc(radius)) {
      centerX = width - radiusX;
      centerY = height - radiusY;
      ArcTo(context, centerX, centerY, radiusX, radiusY, 0, 90, false, iteration);
    } else {
      centerX = width;
      centerY = height;
      ArcTo(context, centerX, centerY, radiusX, radiusY, 270, 180, true, iteration);
    }
  } else {
    context.lineTo(width, height);
  }
  radius = cornerRadius.bl;
  if (IsArcCorner(radius)) {
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    if (IsConvexArc(radius)) {
      centerX = radiusX;
      centerY = height - radiusY;
      ArcTo(context, centerX, centerY, radiusX, radiusY, 90, 180, false, iteration);
    } else {
      centerX = 0;
      centerY = height;
      ArcTo(context, centerX, centerY, radiusX, radiusY, 360, 270, true, iteration);
    }
  } else {
    context.lineTo(0, height);
  }
  context.lineTo(startX, startY);
  context.closePath();
  context.restore();
};
var IsConvexArc = function(radius) {
  return !radius.hasOwnProperty("convex") || radius.convex;
};
var IsArcCorner = function(radius) {
  return radius.x > 0 && radius.y > 0;
};
var ArcTo = function(context, centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration) {
  if (antiClockWise && endAngle > startAngle) {
    endAngle -= 360;
  } else if (!antiClockWise && endAngle < startAngle) {
    endAngle += 360;
  }
  startAngle = DegToRad(startAngle);
  endAngle = DegToRad(endAngle);
  if (iteration == null) {
    context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle, antiClockWise);
  } else {
    iteration += 1;
    var x, y, angle;
    var step = (endAngle - startAngle) / iteration;
    for (var i = 0; i <= iteration; i++) {
      angle = startAngle + step * i;
      x = centerX + radiusX * Math.cos(angle);
      y = centerY + radiusY * Math.sin(angle);
      context.lineTo(x, y);
    }
  }
};
var AddRoundRectanglePath_default = AddRoundRectanglePath;

// node_modules/phaser3-rex-plugins/plugins/utils/canvas/DrawRoundRectangle.js
var DrawRoundRectangle = function(canvas, context, x, y, width, height, radiusConfig, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient, iteration) {
  AddRoundRectanglePath_default(context, x, y, width, height, radiusConfig, iteration);
  if (fillStyle != null) {
    if (fillColor2 != null) {
      var grd;
      if (isHorizontalGradient) {
        grd = context.createLinearGradient(0, 0, width, 0);
      } else {
        grd = context.createLinearGradient(0, 0, 0, height);
      }
      grd.addColorStop(0, fillStyle);
      grd.addColorStop(1, fillColor2);
      fillStyle = grd;
    }
    context.fillStyle = fillStyle;
    context.fill();
  }
  if (strokeStyle != null && lineWidth > 0) {
    context.strokeStyle = strokeStyle;
    context.lineWidth = lineWidth;
    context.stroke();
  }
};
var DrawRoundRectangle_default = DrawRoundRectangle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/canvas/utils/DrawRoundRectangleBackground.js
var DrawRoundRectangleBackground = function(canvasObject, color, strokeColor, strokeLineWidth, radius, color2, isHorizontalGradient, iteration) {
  if (color == null && strokeColor == null) {
    return;
  }
  var width = canvasObject.canvas.width, height = canvasObject.canvas.height;
  if (strokeColor == null) {
    strokeLineWidth = 0;
  }
  var x = strokeLineWidth / 2;
  width = Math.max(1, width - strokeLineWidth);
  height = Math.max(1, height - strokeLineWidth);
  DrawRoundRectangle_default(
    canvasObject.canvas,
    canvasObject.context,
    x,
    x,
    width,
    height,
    radius,
    color,
    strokeColor,
    strokeLineWidth,
    color2,
    isHorizontalGradient,
    iteration
  );
};
var DrawRoundRectangleBackground_default = DrawRoundRectangleBackground;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/canvastext/DrawMethods.js
var DrawMethods_default = {
  draw(startX, startY, textWidth, textHeight) {
    var penManager = this.penManager;
    this.hitAreaManager.clear();
    var context = this.context;
    context.save();
    var defaultStyle = this.defaultStyle;
    this.clear();
    DrawRoundRectangleBackground_default(
      this,
      defaultStyle.backgroundColor,
      defaultStyle.backgroundStrokeColor,
      defaultStyle.backgroundStrokeLineWidth,
      defaultStyle.backgroundCornerRadius,
      defaultStyle.backgroundColor2,
      defaultStyle.backgroundHorizontalGradient,
      defaultStyle.backgroundCornerIteration
    );
    startX += this.startXOffset;
    startY += this.startYOffset;
    var defaultHalign = defaultStyle.halign, valign = defaultStyle.valign;
    var lineWidth, lineHeight = defaultStyle.lineHeight;
    var lines = penManager.lines;
    var totalLinesNum = lines.length, maxLines = defaultStyle.maxLines;
    var drawLinesNum, drawLineStartIdx, drawLineEndIdx;
    if (maxLines > 0 && totalLinesNum > maxLines) {
      drawLinesNum = maxLines;
      if (valign === "center") {
        drawLineStartIdx = Math.floor((totalLinesNum - drawLinesNum) / 2);
      } else if (valign === "bottom") {
        drawLineStartIdx = totalLinesNum - drawLinesNum;
      } else {
        drawLineStartIdx = 0;
      }
    } else {
      drawLinesNum = totalLinesNum;
      drawLineStartIdx = 0;
    }
    drawLineEndIdx = drawLineStartIdx + drawLinesNum;
    var offsetX, offsetY;
    var rtl = this.rtl, rtlOffset = rtl ? this.parent.width : void 0;
    if (valign === "center") {
      offsetY = Math.max((textHeight - drawLinesNum * lineHeight) / 2, 0);
    } else if (valign === "bottom") {
      offsetY = Math.max(textHeight - drawLinesNum * lineHeight - 2, 0);
    } else {
      offsetY = 0;
    }
    offsetY += startY;
    for (var lineIdx = drawLineStartIdx; lineIdx < drawLineEndIdx; lineIdx++) {
      lineWidth = penManager.getLineWidth(lineIdx);
      if (lineWidth === 0) {
        continue;
      }
      var pens = lines[lineIdx], penCount = pens.length;
      var halign = defaultHalign;
      for (var penIdx = 0; penIdx < penCount; penIdx++) {
        var penAlign = pens[penIdx].prop.align;
        if (penAlign !== void 0) {
          halign = penAlign;
          break;
        }
      }
      if (halign === "center") {
        offsetX = (textWidth - lineWidth) / 2;
      } else if (halign === "right") {
        offsetX = !rtl ? textWidth - lineWidth : 0;
      } else {
        offsetX = !rtl ? 0 : textWidth - lineWidth;
      }
      offsetX += startX;
      for (var penIdx = 0; penIdx < penCount; penIdx++) {
        this.drawPen(pens[penIdx], offsetX, offsetY, rtlOffset);
      }
    }
    context.restore();
  },
  drawPen(pen, offsetX, offsetY, rtlOffset) {
    offsetX += pen.x;
    offsetY += pen.y + (pen.prop.y || 0);
    if (rtlOffset !== void 0) {
      offsetX = rtlOffset - offsetX;
    }
    var canvas = this.canvas;
    var context = this.context;
    context.save();
    var curStyle = this.parser.propToContextStyle(this.defaultStyle, pen.prop);
    curStyle.buildFont();
    curStyle.syncFont(canvas, context);
    curStyle.syncStyle(canvas, context);
    if (curStyle.underlineThickness > 0 && pen.width > 0) {
      var lineOffsetY = offsetY + curStyle.underlineOffset - curStyle.underlineThickness / 2;
      this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.underlineThickness, curStyle.underlineColor, curStyle);
    }
    if (pen.isTextPen) {
      this.drawText(offsetX, offsetY, pen.text, curStyle);
    }
    if (pen.isImagePen) {
      this.drawImage(offsetX, offsetY, pen.prop.img, pen.prop.color, curStyle);
    }
    if (curStyle.strikethroughThickness > 0 && pen.width > 0) {
      var lineOffsetY = offsetY + curStyle.strikethroughOffset - curStyle.strikethroughThickness / 2;
      this.drawLine(offsetX, lineOffsetY, pen.width, curStyle.strikethroughThickness, curStyle.strikethroughColor, curStyle);
    }
    context.restore();
    if (pen.hasAreaMarker && pen.width > 0) {
      var data;
      var areaKey = pen.prop.area;
      if (areaKey) {
        data = {
          key: areaKey
        };
      } else {
        var url = pen.prop.url;
        data = {
          key: `url:${url}`,
          url
        };
      }
      this.hitAreaManager.add(
        offsetX,
        offsetY - this.startYOffset,
        pen.width,
        this.defaultStyle.lineHeight,
        data
      );
    }
  },
  clear() {
    var canvas = this.canvas;
    this.context.clearRect(0, 0, canvas.width, canvas.height);
  },
  drawLine(x, y, width, height, color, style) {
    if (this.autoRound) {
      x = Math.round(x);
      y = Math.round(y);
    }
    var context = this.context;
    style.syncShadow(context, style.shadowStroke);
    var savedLineCap = context.lineCap;
    context.lineCap = "butt";
    context.strokeStyle = color;
    context.lineWidth = height;
    context.beginPath();
    context.moveTo(x, y);
    context.lineTo(x + width, y);
    context.stroke();
    context.lineCap = savedLineCap;
  },
  drawText(x, y, text, style) {
    if (this.autoRound) {
      x = Math.round(x);
      y = Math.round(y);
    }
    var context = this.context;
    if (style.stroke && style.stroke !== "none" && style.strokeThickness > 0) {
      style.syncShadow(context, style.shadowStroke);
      context.strokeText(text, x, y);
    }
    if (style.color && style.color !== "none") {
      style.syncShadow(context, style.shadowFill);
      context.fillText(text, x, y);
    }
  },
  drawImage(x, y, imgKey, color, style) {
    y -= this.startYOffset;
    this.parent.imageManager.draw(imgKey, this.context, x, y, color, this.autoRound);
  }
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/penmanger/Pen.js
var GetValue3 = Phaser.Utils.Objects.GetValue;
var NO_NEWLINE = const_default.NO_NEWLINE;
var RAW_NEWLINE = const_default.RAW_NEWLINE;
var Pen = class {
  constructor(config) {
    this.prop = {};
    this.resetFromJSON(config);
  }
  resetFromJSON(o) {
    this.text = GetValue3(o, "text", "");
    this.x = GetValue3(o, "x", 0);
    this.y = GetValue3(o, "y", 0);
    this.width = GetValue3(o, "width", 0);
    var prop = GetValue3(o, "prop", null);
    if (prop === null) {
      prop = {};
    }
    this.prop = prop;
    this.newLineMode = GetValue3(o, "newLineMode", 0);
    this.startIndex = GetValue3(o, "startIndex", 0);
  }
  get plainText() {
    var txt = this.text;
    if (this.newLineMode === RAW_NEWLINE) {
      txt += "\n";
    }
    return txt;
  }
  get wrapText() {
    var txt = this.text;
    if (this.newLineMode !== NO_NEWLINE) {
      txt += "\n";
    }
    return txt;
  }
  get rawTextLength() {
    var len = this.text.length;
    if (this.newLineMode === RAW_NEWLINE) {
      len += 1;
    }
    return len;
  }
  get endIndex() {
    return this.startIndex + this.rawTextLength;
  }
  get lastX() {
    return this.x + this.width;
  }
  get isTextPen() {
    return this.text !== "";
  }
  get isImagePen() {
    return !!this.prop.img;
  }
  get hasAreaMarker() {
    return !!this.prop.area || !!this.prop.url;
  }
};
var Pen_default = Pen;

// node_modules/phaser3-rex-plugins/plugins/utils/object/Clear.js
var Clear = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    obj.length = 0;
  } else {
    for (var key in obj) {
      delete obj[key];
    }
  }
  return obj;
};
var Clear_default = Clear;

// node_modules/phaser3-rex-plugins/plugins/utils/object/Clone.js
var Clone = function(obj, out) {
  var objIsArray = Array.isArray(obj);
  if (out === void 0) {
    out = objIsArray ? [] : {};
  } else {
    Clear_default(out);
  }
  if (objIsArray) {
    out.length = obj.length;
    for (var i = 0, cnt = obj.length; i < cnt; i++) {
      out[i] = obj[i];
    }
  } else {
    for (var key in obj) {
      out[key] = obj[key];
    }
  }
  return out;
};
var Clone_default = Clone;

// node_modules/phaser3-rex-plugins/plugins/utils/object/NOOP.js
var NOOP = function() {
};
var NOOP_default = NOOP;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/penmanger/PenManager.js
var GetFastValue = Phaser.Utils.Objects.GetFastValue;
var NO_NEWLINE2 = const_default.NO_NEWLINE;
var WRAPPED_NEWLINE = const_default.WRAPPED_NEWLINE;
var PenManager = class {
  constructor(config) {
    this.pens = [];
    this.lines = [];
    this.maxLinesWidth = void 0;
    this.pensPool = config.pensPool;
    this.linesPool = config.linesPool;
    this.tagToText = GetFastValue(config, "tagToText", NOOP_default);
    this.tagToTextScope = GetFastValue(config, "tagToTextScope", void 0);
  }
  destroy() {
    this.clear();
    this.tagToText = void 0;
    this.tagToTextScope = void 0;
  }
  clear() {
    for (var i = 0, len = this.lines.length; i < len; i++) {
      this.lines[i].length = 0;
    }
    this.pensPool.pushMultiple(this.pens);
    this.linesPool.pushMultiple(this.lines);
    this.maxLinesWidth = void 0;
  }
  addTextPen(text, x, y, width, prop, newLineMode) {
    var pen = this.pensPool.pop();
    if (pen == null) {
      pen = new Pen_default();
    }
    PEN_CONFIG.text = text;
    PEN_CONFIG.x = x;
    PEN_CONFIG.y = y;
    PEN_CONFIG.width = width;
    PEN_CONFIG.prop = prop;
    PEN_CONFIG.newLineMode = newLineMode;
    pen.resetFromJSON(PEN_CONFIG);
    this.addPen(pen);
    return this;
  }
  addImagePen(x, y, width, prop) {
    this.addTextPen("", x, y, width, prop, NO_NEWLINE2);
    return this;
  }
  addNewLinePen() {
    var previousPen = this.lastPen;
    var x = previousPen ? previousPen.lastX : 0;
    var y = previousPen ? previousPen.y : 0;
    var prop = previousPen ? Clone_default(previousPen.prop) : null;
    this.addTextPen("", x, y, 0, prop, WRAPPED_NEWLINE);
    return this;
  }
  addPen(pen) {
    var previousPen = this.lastPen;
    if (previousPen == null) {
      pen.startIndex = 0;
    } else {
      pen.startIndex = previousPen.endIndex;
    }
    this.pens.push(pen);
    var line = this.lastLine;
    if (line == null) {
      line = this.linesPool.pop() || [];
      this.lines.push(line);
    }
    line.push(pen);
    if (pen.newLineMode !== NO_NEWLINE2) {
      line = this.linesPool.pop() || [];
      this.lines.push(line);
    }
    this.maxLinesWidth = void 0;
  }
  clone(targetPenManager) {
    if (targetPenManager == null)
      targetPenManager = new PenManager();
    targetPenManager.clear();
    for (var li = 0, llen = this.lines.length; li < llen; li++) {
      var pens = this.lines[li];
      for (var pi = 0, plen = pens.length; pi < plen; pi++) {
        var pen = pens[pi];
        targetPenManager.addPen(
          pen.text,
          pen.x,
          pen.y,
          pen.width,
          Clone_default(pen.prop),
          pen.newLineMode
        );
      }
    }
    return targetPenManager;
  }
  get lastPen() {
    return this.pens[this.pens.length - 1];
  }
  get lastLine() {
    return this.lines[this.lines.length - 1];
  }
  getLineStartIndex(i) {
    if (i >= this.lines.length) {
      return this.getLineEndIndex(i);
    } else {
      var line = this.lines[i];
      return line && line[0] ? line[0].startIndex : 0;
    }
  }
  getLineEndIndex(i) {
    if (i >= this.lines.length) {
      i = this.lines.length - 1;
    }
    var li, hasLastPen = false, line;
    for (li = i; li >= 0; li--) {
      line = this.lines[li];
      hasLastPen = line != null && line.length > 0;
      if (hasLastPen) {
        break;
      }
    }
    if (!hasLastPen) {
      return 0;
    }
    var lastPen = line[line.length - 1];
    return lastPen.endIndex;
  }
  getLineWidth(i) {
    var line = this.lines[i];
    if (!line) {
      return 0;
    }
    var lastPen = line[line.length - 1];
    if (lastPen == null) {
      return 0;
    }
    var lineWidth = lastPen.lastX;
    return lineWidth;
  }
  getMaxLineWidth() {
    if (this.maxLinesWidth !== void 0) {
      return this.maxLinesWidth;
    }
    var w, maxW = 0;
    for (var i = 0, len = this.lines.length; i < len; i++) {
      w = this.getLineWidth(i);
      if (w > maxW) {
        maxW = w;
      }
    }
    this.maxLinesWidth = maxW;
    return maxW;
  }
  getLineWidths() {
    var result = [];
    for (var i = 0, len = this.lines.length; i < len; i++) {
      result.push(this.getLineWidth(i));
    }
    return result;
  }
  get linesCount() {
    return this.lines.length;
  }
  get plainText() {
    var txt = "", pens = this.pens;
    for (var i = 0, len = pens.length; i < len; i++) {
      txt += pens[i].plainText;
    }
    return txt;
  }
  get rawTextLength() {
    var l = 0, pens = this.pens;
    for (var i = 0, len = this.pens.length; i < len; i++) {
      l += pens[i].rawTextLength;
    }
    return l;
  }
  getSliceTagText(start, end, wrap) {
    var lastPen = this.lastPen;
    if (lastPen == null) {
      return "";
    }
    var lastPenEnd = lastPen.endIndex;
    if (start === void 0 || start === 0) {
      start = -1;
    }
    if (end === void 0 || end === lastPenEnd) {
      end = lastPenEnd + 1;
    }
    if (wrap === void 0) {
      wrap = false;
    }
    var txt = "", formatTxt, pen, penTxt, penStartIdx, penEndIdx, isInRange;
    var currentProp, previousProp;
    for (var i = 0, len = this.pens.length; i < len; i++) {
      pen = this.pens[i];
      penEndIdx = pen.endIndex;
      if (penEndIdx <= start) {
        continue;
      }
      pen = this.pens[i];
      penTxt = !wrap ? pen.plainText : pen.wrapText;
      currentProp = pen.prop;
      penStartIdx = pen.startIndex;
      isInRange = penStartIdx >= start && penEndIdx <= end;
      if (!isInRange) {
        penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);
      }
      if (this.tagToTextScope) {
        txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);
      } else {
        txt += this.tagToText(penTxt, currentProp, previousProp);
      }
      previousProp = currentProp;
      if (penEndIdx >= end) {
        break;
      }
    }
    return txt;
  }
  get length() {
    return this.lines.length;
  }
  set length(value) {
    this.clear();
  }
};
var PEN_CONFIG = {};
var PenManager_default = PenManager;

// node_modules/phaser3-rex-plugins/plugins/utils/struct/Stack.js
var Stack = class {
  constructor() {
    this.items = [];
  }
  destroy() {
    this.clear();
    this.items = void 0;
  }
  pop() {
    return this.items.length > 0 ? this.items.pop() : null;
  }
  push(l) {
    this.items.push(l);
    return this;
  }
  pushMultiple(arr) {
    this.items.push.apply(this.items, arr);
    arr.length = 0;
    return this;
  }
  clear() {
    this.items.length = 0;
    return this;
  }
};
var Stack_default = Stack;

// node_modules/phaser3-rex-plugins/plugins/pool.js
var pool_default = Stack_default;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/hitareamanager/HitAreaManager.js
var Rectangle = Phaser.Geom.Rectangle;
var RectanglePool = new pool_default();
var HitAreaManager = class {
  constructor() {
    this.hitAreas = [];
  }
  destroy() {
    this.clear();
  }
  clear() {
    for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
      Clear_default(this.hitAreas[i].data);
    }
    RectanglePool.pushMultiple(this.hitAreas);
    return this;
  }
  add(x, y, width, height, data) {
    var rectangle = RectanglePool.pop();
    if (rectangle === null) {
      rectangle = new Rectangle(x, y, width, height);
    } else {
      rectangle.setTo(x, y, width, height);
    }
    rectangle.data = data;
    this.hitAreas.push(rectangle);
    return this;
  }
  getFirst(x, y) {
    for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
      var hitArea = this.hitAreas[i];
      if (hitArea.contains(x, y)) {
        return hitArea;
      }
    }
    return null;
  }
  getByKey(key) {
    for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
      var hitArea = this.hitAreas[i];
      if (hitArea.data.key === key) {
        return hitArea;
      }
    }
    return null;
  }
  drawBounds(graphics, color, parent) {
    if (color === void 0) {
      color = 16777215;
    }
    if (parent) {
      graphics.save().scaleCanvas(parent.scaleX, parent.scaleY).rotateCanvas(parent.rotation).translateCanvas(parent.x, parent.y);
    }
    for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
      var hitArea = this.hitAreas[i];
      graphics.lineStyle(1, color).strokeRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
    }
    if (parent) {
      graphics.restore();
    }
    return this;
  }
};
var HitAreaManager_default = HitAreaManager;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/canvastext/SetInteractive.js
var SetInteractive = function() {
  this.parent.on("pointerdown", OnAreaDown, this).on("pointerup", OnAreaUp, this).on("pointermove", OnAreaOverOut, this).on("pointerover", OnAreaOverOut, this).on("pointerout", function(pointer, event) {
    OnAreaOverOut.call(this, pointer, null, null, event);
  }, this);
};
var OnAreaDown = function(pointer, localX, localY, event) {
  var area = this.hitAreaManager.getFirst(localX, localY);
  if (area === null) {
    return;
  }
  var key = area.data.key;
  FireEvent.call(this, "areadown", key, pointer, localX, localY, event);
  area.data.isDown = true;
};
var OnAreaUp = function(pointer, localX, localY, event) {
  var area = this.hitAreaManager.getFirst(localX, localY);
  if (area === null) {
    return;
  }
  var areaData = area.data;
  var key = areaData.key;
  FireEvent.call(this, "areaup", key, pointer, localX, localY, event);
  if (areaData.isDown) {
    FireEvent.call(this, "areaclick", key, pointer, localX, localY, event);
    var url = areaData.url;
    if (url) {
      window.open(url, "_blank");
    }
  }
  areaData.isDown = false;
};
var OnAreaOverOut = function(pointer, localX, localY, event) {
  if (localX === null) {
    if (this.lastHitAreaKey !== null) {
      FireEvent.call(this, "areaout", this.lastHitAreaKey, pointer, localX, localY, event);
      this.hitAreaManager.getByKey(this.lastHitAreaKey).isDown = false;
      this.lastHitAreaKey = null;
    }
    return;
  }
  var area = this.hitAreaManager.getFirst(localX, localY);
  var key = area ? area.data.key : null;
  if (this.lastHitAreaKey === key) {
    return;
  }
  if (this.lastHitAreaKey !== null) {
    FireEvent.call(this, "areaout", this.lastHitAreaKey, pointer, localX, localY, event);
    var prevHitArea = this.hitAreaManager.getByKey(this.lastHitAreaKey);
    if (this.urlTagCursorStyle && !!prevHitArea.data.url) {
      this.scene.input.manager.canvas.style.cursor = "";
    }
    prevHitArea.isDown = false;
  }
  if (key !== null) {
    FireEvent.call(this, "areaover", key, pointer, localX, localY, event);
    if (this.urlTagCursorStyle && !!area.data.url) {
      this.scene.input.manager.canvas.style.cursor = this.urlTagCursorStyle;
    }
  }
  this.lastHitAreaKey = key;
};
var FireEvent = function(eventName, key, pointer, localX, localY, event) {
  this.parent.emit(`${eventName}-${key}`, pointer, localX, localY, event);
  this.parent.emit(eventName, key, pointer, localX, localY, event);
};
var SetInteractive_default = SetInteractive;

// node_modules/phaser3-rex-plugins/plugins/utils/string/IsASCIIString.js
var RE_ASCII = /^[\x00-\x7F]+$/;
var IsASCIIString = function(s) {
  return RE_ASCII.test(s);
};
var IsASCIIString_default = IsASCIIString;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/wraptext/WrapText.js
var NO_NEWLINE3 = const_default.NO_NEWLINE;
var RAW_NEWLINE2 = const_default.RAW_NEWLINE;
var WRAPPED_NEWLINE2 = const_default.WRAPPED_NEWLINE;
var NO_WRAP = const_default.NO_WRAP;
var WORD_WRAP = const_default.WORD_WRAP;
var CHAR_WRAP = const_default.CHAR_WRAP;
var MIX_WRAP = const_default.MIX_WRAP;
var splitRegExp = const_default.SPLITREGEXP;
var WrapText = function(text, getTextWidth, wrapMode, wrapWidth, offset, wrapTextLinesPool) {
  if (wrapWidth <= 0) {
    wrapMode = NO_WRAP;
  }
  var retLines = [];
  if (!text || !text.length) {
    return retLines;
  }
  var isNoWrap = wrapMode === NO_WRAP;
  var lines = text.split(splitRegExp), line, remainWidth, newLineMode;
  for (var i = 0, linesLen = lines.length; i < linesLen; i++) {
    line = lines[i];
    newLineMode = i === linesLen - 1 ? NO_NEWLINE3 : RAW_NEWLINE2;
    if (isNoWrap) {
      var textWidth = getTextWidth(line);
      retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
      continue;
    }
    remainWidth = i === 0 ? wrapWidth - offset : wrapWidth;
    if (line.length <= 100) {
      var textWidth = getTextWidth(line);
      if (textWidth <= remainWidth) {
        retLines.push(wrapTextLinesPool.getLine(line, textWidth, newLineMode));
        continue;
      }
    }
    var tokenArray = ParseLine(line, wrapMode);
    var token, tokenWidth, isLastToken;
    var lineText = "", lineWidth = 0;
    var currLineWidth;
    for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
      token = tokenArray[j];
      tokenWidth = getTextWidth(token);
      if (tokenWidth > wrapWidth && IsWord(token)) {
        if (lineText !== "") {
          retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE2));
        } else if (j === 0 && offset > 0) {
          retLines.push(wrapTextLinesPool.getLine("", 0, WRAPPED_NEWLINE2));
        }
        retLines.push(...WrapText(token, getTextWidth, CHAR_WRAP, wrapWidth, 0, wrapTextLinesPool));
        var lastwordBreakLine = retLines.pop();
        lineText = lastwordBreakLine.text;
        lineWidth = lastwordBreakLine.width;
        wrapTextLinesPool.freeLine(lastwordBreakLine);
        if (lineText === " ") {
          lineText = "";
          lineWidth = 0;
        }
        continue;
      }
      currLineWidth = lineWidth + tokenWidth;
      if (currLineWidth > remainWidth) {
        retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, WRAPPED_NEWLINE2));
        lineText = token;
        lineWidth = tokenWidth;
        remainWidth = wrapWidth;
      } else {
        lineText += token;
        lineWidth = currLineWidth;
      }
      if (j === tokenLen - 1) {
        retLines.push(wrapTextLinesPool.getLine(lineText, lineWidth, newLineMode));
      }
    }
  }
  return retLines;
};
var ParseLine = function(s, mode) {
  var tokens;
  switch (mode) {
    case WORD_WRAP:
      tokens = [];
      s = s.split(" ");
      for (var i = 0, icnt = s.length; i < icnt; i++) {
        var token = s[i];
        if (i < icnt - 1) {
          tokens.push(token + " ");
        } else {
          if (token !== "") {
            tokens.push(token);
          }
        }
      }
      break;
    case CHAR_WRAP:
      tokens = s.split("");
      break;
    default:
      tokens = [];
      s = s.split(" ");
      for (var i = 0, icnt = s.length; i < icnt; i++) {
        var token = s[i];
        if (i < icnt - 1) {
          if (IsASCIIString_default(token)) {
            tokens.push(token + " ");
          } else {
            tokens.push(...token.split(""));
            tokens.push(" ");
          }
        } else {
          if (token !== "") {
            if (IsASCIIString_default(token)) {
              tokens.push(token);
            } else {
              tokens.push(...token.split(""));
            }
          }
        }
      }
      break;
  }
  return tokens;
};
var IsWord = function(s) {
  switch (s.length) {
    case 1:
      return false;
    case 2:
      return s.charAt(1) !== " ";
    default:
      return true;
  }
};
var WrapText_default = WrapText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/canvastext/CanvasText.js
var GetValue4 = Phaser.Utils.Objects.GetValue;
var NO_WRAP2 = const_default.NO_WRAP;
var NO_NEWLINE4 = const_default.NO_NEWLINE;
var CanvasText = class {
  constructor(config) {
    this.parent = config.parent;
    this.scene = this.parent.scene;
    this.context = GetValue4(config, "context", null);
    this.canvas = this.context.canvas;
    this.parser = GetValue4(config, "parser", null);
    this.defaultStyle = GetValue4(config, "style", null);
    this.autoRound = true;
    this.pensPool = config.pensPool;
    this.linesPool = config.linesPool;
    this.wrapTextLinesPool = config.wrapTextLinesPool;
    this.penManager = this.newPenManager();
    this._tmpPenManager = null;
    this.hitAreaManager = new HitAreaManager_default();
    this.lastHitAreaKey = null;
    this.urlTagCursorStyle = null;
    var context = this.context;
    this.getTextWidth = function(text) {
      return context.measureText(text).width;
    };
  }
  destroy() {
    this.parent = void 0;
    this.scene = void 0;
    this.context = void 0;
    this.canvas = void 0;
    this.parser = void 0;
    this.defaultStyle = void 0;
    if (this.penManager) {
      this.penManager.destroy();
      this.penManager = void 0;
    }
    if (this._tmpPenManager) {
      this._tmpPenManager.destroy();
      this._tmpPenManager = void 0;
    }
    if (this.hitAreaManager) {
      this.hitAreaManager.destroy();
      this.hitAreaManager = void 0;
    }
    this.pensPool = void 0;
    this.linesPool = void 0;
    this.wrapTextLinesPool = void 0;
  }
  updatePenManager(text, wrapMode, wrapWidth, lineHeight, penManager) {
    if (penManager === void 0) {
      penManager = this.penManager;
    }
    penManager.clear();
    if (text === "") {
      return penManager;
    }
    var textStyle = this.parent.style;
    if (textStyle.isWrapFitMode) {
      var padding = this.parent.padding;
      wrapWidth = textStyle.fixedWidth - padding.left - padding.right;
    }
    var canvas = this.canvas;
    var context = this.context;
    var MeasureText2 = function(text2) {
      return context.measureText(text2).width;
    };
    var cursorX = 0, cursorY = 0;
    var customTextWrapCallback = textStyle.wrapCallback, customTextWrapCallbackScope = textStyle.wrapCallbackScope;
    var reuseLines = true;
    var plainText, curProp, curStyle;
    var match = this.parser.splitText(text), result, wrapLines, wrapTextLinesPool = this.wrapTextLinesPool;
    for (var i = 0, len = match.length; i < len; i++) {
      result = this.parser.tagTextToProp(match[i], curProp);
      plainText = result.plainText;
      curProp = result.prop;
      if (curProp.img) {
        var imgWidth = this.imageManager.getOuterWidth(curProp.img);
        if (wrapWidth > 0 && wrapMode !== NO_WRAP2) {
          if (wrapWidth < cursorX + imgWidth) {
            penManager.addNewLinePen();
            cursorY += lineHeight;
            cursorX = 0;
          }
        }
        penManager.addImagePen(cursorX, cursorY, imgWidth, Clone_default(curProp));
        cursorX += imgWidth;
      } else if (plainText !== "") {
        context.save();
        curStyle = this.parser.propToContextStyle(this.defaultStyle, curProp);
        curStyle.buildFont();
        curStyle.syncFont(canvas, context);
        curStyle.syncStyle(canvas, context);
        if (!customTextWrapCallback) {
          wrapLines = WrapText_default(
            plainText,
            MeasureText2,
            wrapMode,
            wrapWidth,
            cursorX,
            wrapTextLinesPool
          );
        } else {
          wrapLines = customTextWrapCallback.call(
            customTextWrapCallbackScope,
            plainText,
            MeasureText2,
            wrapWidth,
            cursorX
          );
          if (typeof wrapLines === "string") {
            wrapLines = wrapLines.split("\n");
          }
          var n;
          for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
            n = wrapLines[j];
            if (typeof n === "string") {
              wrapLines[j] = wrapTextLinesPool.getLine(
                n,
                MeasureText2(n),
                j < jLen - 1 ? 2 : 0
              );
            } else {
              reuseLines = false;
            }
          }
        }
        var n;
        for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
          n = wrapLines[j];
          penManager.addTextPen(n.text, cursorX, cursorY, n.width, Clone_default(curProp), n.newLineMode);
          if (n.newLineMode !== NO_NEWLINE4) {
            cursorX = 0;
            cursorY += lineHeight;
          } else {
            cursorX += n.width;
          }
        }
        if (reuseLines) {
          wrapTextLinesPool.freeLines(wrapLines);
        }
        wrapLines = null;
        context.restore();
      }
    }
    for (var i = 0, len = this.lines.length; i < len; i++) {
      var line = this.lines[i];
      var lastPen = line[line.length - 1];
      if (lastPen) {
        lastPen.width += this.parser.getStrokeThinkness(this.defaultStyle, lastPen.prop);
      }
    }
    return penManager;
  }
  get startXOffset() {
    var defaultStyle = this.defaultStyle;
    return defaultStyle.strokeThickness / 2 + defaultStyle.xOffset;
  }
  get startYOffset() {
    var defaultStyle = this.defaultStyle;
    return defaultStyle.strokeThickness / 2 + defaultStyle.metrics.ascent;
  }
  get lines() {
    return this.penManager.lines;
  }
  get desplayLinesCount() {
    var linesCount = this.penManager.linesCount, maxLines = this.defaultStyle.maxLines;
    if (maxLines > 0 && linesCount > maxLines) {
      linesCount = maxLines;
    }
    return linesCount;
  }
  get linesWidth() {
    return Math.ceil(this.penManager.getMaxLineWidth());
  }
  get linesHeight() {
    var linesCount = this.desplayLinesCount;
    var linesHeight = this.defaultStyle.lineHeight * linesCount;
    if (linesCount > 0) {
      linesHeight -= this.defaultStyle.lineSpacing;
    }
    return linesHeight;
  }
  get imageManager() {
    return this.parent.imageManager;
  }
  get rtl() {
    return this.parent.style.rtl;
  }
  newPenManager() {
    return new PenManager_default({
      pensPool: this.pensPool,
      linesPool: this.linesPool,
      tagToText: this.parser.propToTagText,
      tagToTextScope: this.parser
    });
  }
  get tmpPenManager() {
    if (this._tmpPenManager === null) {
      this._tmpPenManager = this.newPenManager();
    }
    return this._tmpPenManager;
  }
  getPlainText(text, start, end) {
    var plainText;
    if (text == null) {
      plainText = this.penManager.plainText;
    } else {
      var m, match = this.parser.splitText(text, 1);
      plainText = "";
      for (var i = 0, len = match.length; i < len; i++) {
        plainText += match[i];
      }
    }
    if (start != null || end != null) {
      if (start == null) {
        start = 0;
      }
      if (end == null) {
        end = plainText.length;
      }
      plainText = plainText.substring(start, end);
    }
    return plainText;
  }
  getPenManager(text, retPenManager) {
    if (text === void 0) {
      return this.copyPenManager(retPenManager, this.penManager);
    }
    if (retPenManager === void 0) {
      retPenManager = this.newPenManager();
    }
    var defaultStyle = this.defaultStyle;
    this.updatePenManager(
      text,
      defaultStyle.wrapMode,
      defaultStyle.wrapWidth,
      defaultStyle.lineHeight,
      retPenManager
    );
    return retPenManager;
  }
  getText(text, start, end, wrap) {
    if (text == null) {
      return this.penManager.getSliceTagText(start, end, wrap);
    }
    var penManager = this.tmpPenManager;
    var defaultStyle = this.defaultStyle;
    this.updatePenManager(
      text,
      defaultStyle.wrapMode,
      defaultStyle.wrapWidth,
      defaultStyle.lineHeight,
      penManager
    );
    return penManager.getSliceTagText(start, end, wrap);
  }
  copyPenManager(ret, src) {
    if (src === void 0) {
      src = this.penManager;
    }
    return src.copy(ret);
  }
  getTextWidth(penManager) {
    if (penManager === void 0) {
      penManager = this.penManager;
    }
    return penManager.getMaxLineWidth();
  }
  getLastPen(penManager) {
    if (penManager === void 0) {
      penManager = this.penManager;
    }
    return penManager.lastPen;
  }
};
var methods = {
  setInteractive: SetInteractive_default
};
Object.assign(
  CanvasText.prototype,
  DrawMethods_default,
  methods
);
var CanvasText_default = CanvasText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/wraptext/WrapTextLinesPool.js
var WrapTextLinesPool = class extends pool_default {
  freeLine(line) {
    if (!line) {
      return;
    }
    this.push(line);
    return this;
  }
  freeLines(lines) {
    if (!lines) {
      return;
    }
    this.pushMultiple(lines);
    return this;
  }
  getLine(text, width, newLineMode) {
    var l = this.pop();
    if (l === null) {
      l = {};
    }
    l.text = text;
    l.width = width;
    l.newLineMode = newLineMode;
    return l;
  }
};
var WrapTextLinesPool_default = WrapTextLinesPool;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/imagemanager/AddImage.js
var IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
var GetValue5 = Phaser.Utils.Objects.GetValue;
var AddImage = function(key, config) {
  if (IsPlainObject(key)) {
    config = key;
    key = config.key;
  } else if (config === void 0) {
    config = {
      key
    };
  }
  if (!config.hasOwnProperty("key")) {
    config.key = key;
  }
  var textureKey = config.key, frameKey = config.frame;
  var width = config.width, height = config.height;
  if (width === void 0 || height === void 0) {
    var frame = this.textureManager.getFrame(textureKey, frameKey);
    var frameWidth = frame ? frame.cutWidth : 0;
    var frameHeight = frame ? frame.cutHeight : 0;
    if (width === void 0 && height === void 0) {
      width = frameWidth;
      height = frameHeight;
    } else if (width === void 0) {
      width = frameWidth * (height / frameHeight);
    } else if (height === void 0) {
      height = frameHeight * (width / frameWidth);
    }
  }
  this.images[key] = {
    key: textureKey,
    frame: frameKey,
    width,
    height,
    y: GetValue5(config, "y", 0),
    left: GetValue5(config, "left", 0),
    right: GetValue5(config, "right", 0),
    originX: GetValue5(config, "originX", 0),
    originY: GetValue5(config, "originY", 0),
    tintFill: GetValue5(config, "tintFill", false)
  };
};
var AddImage_default = AddImage;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/DrawFrameToCanvas.js
var CanvasPool3 = Phaser.Display.Canvas.CanvasPool;
var DrawFrameToCanvas = function(frame, canvas, x, y, width, height, color, autoRound) {
  if (x === void 0) {
    x = 0;
  }
  if (y === void 0) {
    y = 0;
  }
  if (width === void 0) {
    width = frame.cutWidth;
  }
  if (height === void 0) {
    height = frame.cutHeight;
  }
  if (autoRound === void 0) {
    autoRound = false;
  }
  ;
  if (autoRound) {
    x = Math.round(x);
    y = Math.round(y);
  }
  var context = canvas.getContext("2d", { willReadFrequently: true });
  if (color) {
    var tempCanvas = CanvasPool3.create(null, width, height, Phaser.CANVAS, true);
    var tempContext = tempCanvas.getContext("2d", { willReadFrequently: true });
    tempContext.drawImage(
      frame.source.image,
      frame.cutX,
      frame.cutY,
      frame.cutWidth,
      frame.cutHeight,
      0,
      0,
      width,
      height
    );
    tempContext.globalCompositeOperation = "source-in";
    tempContext.fillStyle = color;
    tempContext.fillRect(0, 0, width, height);
    context.drawImage(
      tempCanvas,
      0,
      0,
      width,
      height,
      x,
      y,
      width,
      height
    );
    CanvasPool3.remove(tempCanvas);
  } else {
    context.drawImage(
      frame.source.image,
      frame.cutX,
      frame.cutY,
      frame.cutWidth,
      frame.cutHeight,
      x,
      y,
      width,
      height
    );
  }
};
var DrawFrameToCanvas_default = DrawFrameToCanvas;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/imagemanager/DrawImage.js
var DrawImage = function(key, context, x, y, color, autoRound) {
  var imgData = this.get(key);
  if (!imgData) {
    return;
  }
  var frame = this.textureManager.getFrame(imgData.key, imgData.frame);
  var width = imgData.width, height = imgData.height;
  x += imgData.left - imgData.originX * width;
  y += imgData.y - imgData.originY * height;
  if (!imgData.tintFill) {
    color = void 0;
  }
  DrawFrameToCanvas_default(
    frame,
    context.canvas,
    x,
    y,
    width,
    height,
    color,
    autoRound
  );
};
var DrawImage_default = DrawImage;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/imagemanager/ImageManager.js
var ImageManager = class {
  constructor(scene) {
    this.textureManager = scene.sys.textures;
    this.images = {};
  }
  destroy() {
    this.textureManager = void 0;
    this.images = void 0;
  }
  add(key, config) {
    if (typeof key === "string") {
      AddImage_default.call(this, key, config);
    } else if (Array.isArray(key)) {
      var data = key;
      for (var i = 0, cnt = data.length; i < cnt; i++) {
        AddImage_default.call(this, data[i]);
      }
    } else {
      var data = key;
      for (var key in data) {
        AddImage_default.call(this, key, data[key]);
      }
    }
    return this;
  }
  has(key) {
    return this.images.hasOwnProperty(key);
  }
  remove(key) {
    if (this.has(key)) {
      delete this.images[key];
    }
    return this;
  }
  get(key) {
    if (!this.has(key)) {
      if (this.textureManager.exists(key)) {
        this.add(key);
      }
    }
    return this.images[key];
  }
  getOuterWidth(key) {
    var data = this.get(key);
    return data ? data.width + data.left + data.right : 0;
  }
  getFrame(key) {
    var data = this.get(key);
    return data ? this.textureManager.getFrame(data.key, data.frame) : void 0;
  }
  hasTexture(key) {
    return !!this.getFrame(key);
  }
};
var methods2 = {
  draw: DrawImage_default
};
Object.assign(
  ImageManager.prototype,
  methods2
);
var ImageManager_default = ImageManager;

// node_modules/phaser3-rex-plugins/plugins/utils/texture/CopyCanvasToTexture.js
var CopyCanvasToTexture = function(scene, srcCanvas, key, x, y, width, height) {
  var textures = scene.sys.textures;
  var renderer = scene.renderer;
  if (x === void 0) {
    x = 0;
  }
  if (y === void 0) {
    y = 0;
  }
  if (width === void 0) {
    width = srcCanvas.width;
  }
  if (height === void 0) {
    height = srcCanvas.height;
  }
  var texture;
  if (textures.exists(key)) {
    texture = textures.get(key);
  } else {
    texture = textures.createCanvas(key, width, height);
  }
  var destCanvas = texture.getSourceImage();
  if (destCanvas.width !== width) {
    destCanvas.width = width;
  }
  if (destCanvas.height !== height) {
    destCanvas.height = height;
  }
  var destCtx = destCanvas.getContext("2d", { willReadFrequently: true });
  destCtx.clearRect(0, 0, width, height);
  destCtx.drawImage(srcCanvas, x, y, width, height);
  if (renderer.gl && texture) {
    renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);
  }
};
var CopyCanvasToTexture_default = CopyCanvasToTexture;

// node_modules/phaser3-rex-plugins/plugins/utils/text/AppendText.js
var AppendText = function(value, addCR) {
  if (!value && value !== 0) {
    value = "";
  }
  if (addCR === void 0) {
    addCR = true;
  }
  if (Array.isArray(value)) {
    value = value.join("\n");
  }
  var newText;
  if (addCR) {
    newText = `${this.text}
${value}`;
  } else {
    newText = `${this.text}${value}`;
  }
  if (newText != this.text) {
    this.setText(newText);
  }
  return this;
};
var AppendText_default = AppendText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/textbase/Text.js
var IsPlainObject2 = Phaser.Utils.Objects.IsPlainObject;
var AddToDOM = Phaser.DOM.AddToDOM;
var CanvasPool4 = Phaser.Display.Canvas.CanvasPool;
var GameObject2 = Phaser.GameObjects.GameObject;
var GetValue6 = Phaser.Utils.Objects.GetValue;
var RemoveFromDOM = Phaser.DOM.RemoveFromDOM;
var SPLITREGEXP = const_default.SPLITREGEXP;
var UUID = Phaser.Utils.String.UUID;
var SharedPensPools = null;
var SharedLinesPool = null;
var SharedWrapTextLinesPool = null;
var Text = class extends TextBase_default {
  constructor(scene, x, y, text, style, type, parser) {
    if (IsPlainObject2(x)) {
      var config = x;
      x = GetValue6(config, "x", 0);
      y = GetValue6(config, "y", 0);
      text = GetValue6(config, "text", "");
      style = GetValue6(config, "style");
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    super(scene, type);
    this.renderer = scene.sys.game.renderer;
    this.setPosition(x, y);
    this.setOrigin(0, 0);
    this.initPipeline();
    this.initPostPipeline(true);
    this.canvas = CanvasPool4.create(this);
    this.context = this.canvas.getContext("2d", { willReadFrequently: true });
    this._imageManager = void 0;
    if (style) {
      if (style.hasOwnProperty("align")) {
        var halign = style.align;
        delete style.align;
        style.halign = halign;
      }
      if (style.hasOwnProperty("stroke") && !style.hasOwnProperty("strokeThickness")) {
        style.strokeThickness = 1;
      }
    }
    this.style = new TextStyle_default(this, style);
    var imageData = GetValue6(style, "images", void 0);
    if (imageData) {
      this.addImage(imageData);
    }
    this.autoRound = true;
    this._text = void 0;
    this.padding = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.width = 1;
    this.height = 1;
    this.lineSpacing = 0;
    this.dirty = false;
    if (this.style.resolution === 0) {
      this.style.resolution = 1;
    }
    this._crop = this.resetCropObject();
    this._textureKey = UUID();
    this.texture = scene.sys.textures.addCanvas(this._textureKey, this.canvas);
    this.frame = this.texture.get();
    this.frame.source.resolution = this.style.resolution;
    if (this.renderer && this.renderer.gl) {
      this.renderer.deleteTexture(this.frame.source.glTexture);
      this.frame.source.glTexture = null;
    }
    var sharedPoolMode = GetValue6(style, "sharedPool", true);
    var pensPool, linesPool, wrapTextLinesPool;
    if (sharedPoolMode) {
      if (!SharedPensPools) {
        SharedPensPools = {};
        SharedLinesPool = new pool_default();
        SharedWrapTextLinesPool = new WrapTextLinesPool_default();
        this.scene.game.events.once("destroy", function() {
          SharedPensPools = null;
          SharedLinesPool = null;
          SharedWrapTextLinesPool = null;
        });
      }
      if (!SharedPensPools.hasOwnProperty(type)) {
        SharedPensPools[type] = new pool_default();
      }
      pensPool = SharedPensPools[type];
      linesPool = SharedLinesPool;
      wrapTextLinesPool = SharedWrapTextLinesPool;
    } else {
      pensPool = new pool_default();
      linesPool = new pool_default();
      wrapTextLinesPool = new WrapTextLinesPool_default();
    }
    this.canvasText = new CanvasText_default({
      parent: this,
      context: this.context,
      parser,
      style: this.style,
      pensPool,
      linesPool,
      wrapTextLinesPool
    });
    this.parser = parser;
    this.initRTL();
    if (style && style.padding) {
      this.setPadding(style.padding);
    }
    if (style && style.lineSpacing) {
      this.setLineSpacing(style.lineSpacing);
    }
    this.setText(text);
    this.setUrlTagCursorStyle(GetValue6(style, "urlTagCursorStyle", "pointer"));
    if (GetValue6(style, "interactive", false)) {
      this.setInteractive();
    }
  }
  preDestroy() {
    RemoveFromDOM(this.canvas);
    this.canvasText.destroy();
    this.canvasText = void 0;
    if (this._imageManager) {
      this._imageManager.destroy();
      this._imageManager = void 0;
    }
    CanvasPool4.remove(this.canvas);
    var texture = this.texture;
    if (texture) {
      texture.destroy();
    }
  }
  set text(value) {
    this.setText(value);
  }
  get text() {
    return this._text;
  }
  initRTL() {
    if (!this.style.rtl) {
      return;
    }
    this.canvas.dir = "rtl";
    this.context.direction = "rtl";
    this.canvas.style.display = "none";
    AddToDOM(this.canvas, this.scene.sys.canvas);
    this.originX = 1;
  }
  setRTL(rtl) {
    if (rtl === void 0) {
      rtl = true;
    }
    var style = this.style;
    if (style.rtl === rtl) {
      return this;
    }
    style.rtl = rtl;
    if (rtl) {
      this.canvas.dir = "rtl";
      this.context.direction = "rtl";
      this.canvas.style.display = "none";
      AddToDOM(this.canvas, this.scene.sys.canvas);
    } else {
      this.canvas.dir = "ltr";
      this.context.direction = "ltr";
    }
    if (style.halign === "left") {
      style.halign = "right";
    } else if (style.halign === "right") {
      style.halign = "left";
    }
    if (this._imageManager) {
      var images = this._imageManager.images;
      for (var key in images) {
        images[key].originX = 1 - images[key].originX;
      }
    }
    return this;
  }
  setText(value) {
    if (value == null) {
      value = "";
    } else if (Array.isArray(value)) {
      value = value.join("\n");
    } else {
      value = value.toString();
    }
    if (value === this._text) {
      return this;
    }
    this._text = value;
    this.updateText();
    return this;
  }
  setPadding(left, top, right, bottom) {
    if (typeof left === "object") {
      var config = left;
      var x = GetValue6(config, "x", null);
      if (x !== null) {
        left = x;
        right = x;
      } else {
        left = GetValue6(config, "left", 0);
        right = GetValue6(config, "right", left);
      }
      var y = GetValue6(config, "y", null);
      if (y !== null) {
        top = y;
        bottom = y;
      } else {
        top = GetValue6(config, "top", 0);
        bottom = GetValue6(config, "bottom", top);
      }
    } else {
      if (left === void 0) {
        left = 0;
      }
      if (top === void 0) {
        top = left;
      }
      if (right === void 0) {
        right = left;
      }
      if (bottom === void 0) {
        bottom = top;
      }
    }
    this.padding.left = left;
    this.padding.top = top;
    this.padding.right = right;
    this.padding.bottom = bottom;
    return this.updateText(false);
  }
  updateText(runWrap) {
    if (runWrap === void 0) {
      runWrap = true;
    }
    var canvasText = this.canvasText;
    var style = this.style;
    if (runWrap) {
      canvasText.updatePenManager(
        this._text,
        style.wrapMode,
        style.wrapWidth,
        style.lineHeight
      );
    }
    var padding = this.padding;
    var textWidth, textHeight;
    var linesWidth = Math.ceil(canvasText.linesWidth);
    if (style.fixedWidth === 0) {
      this.width = linesWidth + padding.left + padding.right;
      textWidth = linesWidth;
    } else {
      this.width = style.fixedWidth;
      textWidth = this.width - padding.left - padding.right;
      if (textWidth < linesWidth) {
        textWidth = linesWidth;
      }
    }
    if (style.fixedHeight === 0) {
      this.height = canvasText.linesHeight + padding.top + padding.bottom;
      textHeight = canvasText.linesHeight;
    } else {
      this.height = style.fixedHeight;
      textHeight = this.height - padding.top - padding.bottom;
      if (textHeight < canvasText.linesHeight) {
        textHeight = canvasText.linesHeight;
      }
    }
    var w = this.width;
    var h = this.height;
    this.updateDisplayOrigin();
    var resolution = style.resolution;
    w *= resolution;
    h *= resolution;
    w = Math.max(Math.ceil(w), 1);
    h = Math.max(Math.ceil(h), 1);
    var canvas = this.canvas;
    var context = this.context;
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      this.frame.setSize(w, h);
    } else {
      context.clearRect(0, 0, w, h);
    }
    context.save();
    context.scale(resolution, resolution);
    var startX = !this.style.rtl ? padding.left : padding.right;
    var startY = padding.top;
    canvasText.draw(
      startX,
      startY,
      textWidth,
      textHeight
    );
    context.restore();
    if (this.renderer && this.renderer.gl) {
      this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
      if (typeof WEBGL_DEBUG) {
        this.frame.glTexture.spectorMetadata = { textureKey: "BBCodeText Game Object" };
      }
    }
    this.dirty = true;
    var input = this.input;
    if (input && !input.customHitArea) {
      input.hitArea.width = this.width;
      input.hitArea.height = this.height;
    }
    return this;
  }
  toJSON() {
    var out = Components.ToJSON(this);
    var data = {
      autoRound: this.autoRound,
      text: this._text,
      style: this.style.toJSON(),
      resolution: this.resolution,
      padding: {
        left: this.padding.left,
        right: this.padding.right,
        top: this.padding.top,
        bottom: this.padding.bottom
      }
    };
    out.data = data;
    return out;
  }
  setInteractive(hitArea, hitAreaCallback, dropZone) {
    var isInteractived = !!this.input;
    GameObject2.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);
    if (!isInteractived) {
      this.canvasText.setInteractive();
    }
    return this;
  }
  setUrlTagCursorStyle(cursor) {
    this.urlTagCursorStyle = cursor;
    return this;
  }
  get urlTagCursorStyle() {
    return this.canvasText.urlTagCursorStyle;
  }
  set urlTagCursorStyle(value) {
    this.canvasText.urlTagCursorStyle = value;
  }
  getWrappedText(text, start, end) {
    if (typeof text === "number") {
      end = start;
      start = text;
      text = void 0;
    }
    text = this.canvasText.getText(text, start, end, true);
    return text.split(SPLITREGEXP);
  }
  getPlainText(text, start, end) {
    if (typeof text === "number") {
      end = start;
      start = text;
      text = void 0;
    }
    return this.canvasText.getPlainText(text, start, end);
  }
  getText(text, start, end, wrap) {
    if (typeof text === "number") {
      wrap = end;
      end = start;
      start = text;
      text = void 0;
    }
    if (wrap === void 0) {
      wrap = false;
    }
    return this.canvasText.getText(text, start, end, wrap);
  }
  getSubString(text, start, end) {
    if (typeof text === "number") {
      end = start;
      start = text;
      text = void 0;
    }
    return this.getText(text, start, end);
  }
  copyPenManager(penManager) {
    return this.canvasText.copyPenManager(penManager);
  }
  getPenManager(text, penManager) {
    return this.canvasText.getPenManager(text, penManager);
  }
  setSize(width, height) {
    return this.setFixedSize(width, height);
  }
  resize(width, height) {
    return this.setFixedSize(width, height);
  }
  get imageManager() {
    if (!this._imageManager) {
      this._imageManager = new ImageManager_default(this.scene);
    }
    return this._imageManager;
  }
  addImage(key, config) {
    this.imageManager.add(key, config);
    return this;
  }
  drawAreaBounds(graphics, color) {
    this.canvasText.hitAreaManager.drawBounds(graphics, color, this);
    return this;
  }
  generateTexture(key, x, y, width, height) {
    var srcCanvas = this.canvas;
    if (width === void 0) {
      width = srcCanvas.width;
    } else {
      width *= this.resolution;
    }
    if (height === void 0) {
      height = srcCanvas.height;
    } else {
      height *= this.resolution;
    }
    CopyCanvasToTexture_default(this.scene, srcCanvas, key, x, y, width, height);
    return this;
  }
};
var methods3 = {
  appendText: AppendText_default
};
Object.assign(
  Text.prototype,
  methods3
);
var Text_default = Text;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/SplitText.js
var SplitText = function(text, mode) {
  var TagRegex = this.tagRegex;
  var result = [];
  var charIdx = 0;
  var rawMode = false, escMode = false;
  while (true) {
    var regexResult = TagRegex.RE_SPLITTEXT.exec(text);
    if (!regexResult) {
      break;
    }
    var match = regexResult[0];
    if (escMode) {
      if (TagRegex.RE_ESC_CLOSE.test(match)) {
        escMode = false;
      } else {
        continue;
      }
    } else if (rawMode) {
      if (TagRegex.RE_RAW_CLOSE.test(match)) {
        rawMode = false;
      } else {
        continue;
      }
    } else {
      if (TagRegex.RE_ESC_OPEN.test(match)) {
        escMode = true;
      } else if (TagRegex.RE_RAW_OPEN.test(match)) {
        rawMode = true;
      }
    }
    var matchEnd = TagRegex.RE_SPLITTEXT.lastIndex;
    var matchStart = matchEnd - match.length;
    if (charIdx < matchStart) {
      var content = text.substring(charIdx, matchStart);
      result.push(content);
    }
    if (mode === void 0) {
      result.push(match);
    }
    charIdx = matchEnd;
  }
  var totalLen = text.length;
  if (charIdx < totalLen) {
    result.push(text.substring(charIdx, totalLen));
  }
  return result;
};
var SplitText_default = SplitText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/TagTextToProp.js
var PROP_REMOVE = false;
var PROP_ADD = true;
var GETPROP_RESULT = {
  plainText: null,
  prevProp: null
};
var TagTextToProp = function(text, prevProp) {
  var TagRegex = this.tagRegex;
  if (prevProp == null) {
    prevProp = {};
  }
  var plainText = "";
  if (prevProp.img) {
    UpdateProp(prevProp, PROP_REMOVE, "img");
  }
  if (prevProp.esc) {
    if (TagRegex.RE_ESC_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "esc");
    } else {
      plainText = text;
    }
  } else if (prevProp.raw) {
    if (TagRegex.RE_RAW_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "raw");
    } else {
      plainText = text;
    }
  } else {
    if (TagRegex.RE_ESC_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "esc", true);
    } else if (TagRegex.RE_ESC_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "esc");
    } else if (TagRegex.RE_RAW_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "raw", true);
    } else if (TagRegex.RE_RAW_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "raw");
    } else if (TagRegex.RE_BLOD_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "b", true);
    } else if (TagRegex.RE_BLOD_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "b");
    } else if (TagRegex.RE_ITALICS_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "i", true);
    } else if (TagRegex.RE_ITALICS_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "i");
    } else if (TagRegex.RE_WEIGHT_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_WEIGHT_OPEN);
      UpdateProp(prevProp, PROP_ADD, "weight", innerMatch[1]);
    } else if (TagRegex.RE_WEIGHT_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "weight");
    } else if (TagRegex.RE_SIZE_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_SIZE_OPEN);
      UpdateProp(prevProp, PROP_ADD, "size", `${innerMatch[1]}px`);
    } else if (TagRegex.RE_SIZE_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "size");
    } else if (TagRegex.RE_COLOR_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_COLOR_OPEN);
      UpdateProp(prevProp, PROP_ADD, "color", innerMatch[1]);
    } else if (TagRegex.RE_COLOR_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "color");
    } else if (TagRegex.RE_UNDERLINE_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "u", true);
    } else if (TagRegex.RE_UNDERLINE_OPENC.test(text)) {
      var innerMatch = text.match(TagRegex.RE_UNDERLINE_OPENC);
      UpdateProp(prevProp, PROP_ADD, "u", innerMatch[1]);
    } else if (TagRegex.RE_UNDERLINE_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "u");
    } else if (TagRegex.RE_STRIKETHROUGH_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "s", true);
    } else if (TagRegex.RE_STRIKETHROUGH_OPENC.test(text)) {
      var innerMatch = text.match(TagRegex.RE_STRIKETHROUGH_OPENC);
      UpdateProp(prevProp, PROP_ADD, "s", innerMatch[1]);
    } else if (TagRegex.RE_STRIKETHROUGH_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "s");
    } else if (TagRegex.RE_SHADOW_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "shadow", true);
    } else if (TagRegex.RE_SHADOW_OPENC.test(text)) {
      var innerMatch = text.match(TagRegex.RE_SHADOW_OPENC);
      UpdateProp(prevProp, PROP_ADD, "shadow", innerMatch[1]);
    } else if (TagRegex.RE_SHADOW_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "shadow");
    } else if (TagRegex.RE_STROKE_OPEN.test(text)) {
      UpdateProp(prevProp, PROP_ADD, "stroke", true);
    } else if (TagRegex.RE_STROKE_OPENC.test(text)) {
      var innerMatch = text.match(TagRegex.RE_STROKE_OPENC);
      UpdateProp(prevProp, PROP_ADD, "stroke", innerMatch[1]);
    } else if (TagRegex.RE_STROKE_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "stroke");
    } else if (TagRegex.RE_OFFSETY_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_OFFSETY_OPEN);
      UpdateProp(prevProp, PROP_ADD, "y", parseFloat(innerMatch[1]));
    } else if (TagRegex.RE_OFFSETY_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "y");
    } else if (TagRegex.RE_IMAGE_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_IMAGE_OPEN);
      UpdateProp(prevProp, PROP_ADD, "img", innerMatch[1]);
    } else if (TagRegex.RE_IMAGE_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "img");
    } else if (TagRegex.RE_AREA_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_AREA_OPEN);
      UpdateProp(prevProp, PROP_ADD, "area", innerMatch[1]);
    } else if (TagRegex.RE_AREA_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "area");
    } else if (TagRegex.RE_URL_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_URL_OPEN);
      UpdateProp(prevProp, PROP_ADD, "url", innerMatch[1]);
    } else if (TagRegex.RE_URL_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "url");
    } else if (TagRegex.RE_ALIGN_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_ALIGN_OPEN);
      UpdateProp(prevProp, PROP_ADD, "align", innerMatch[1]);
    } else if (TagRegex.RE_ALIGN_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "align");
    } else if (TagRegex.RE_ID_OPEN.test(text)) {
      var innerMatch = text.match(TagRegex.RE_ID_OPEN);
      UpdateProp(prevProp, PROP_ADD, "id", innerMatch[1]);
    } else if (TagRegex.RE_ID_CLOSE.test(text)) {
      UpdateProp(prevProp, PROP_REMOVE, "id");
    } else {
      plainText = text;
    }
  }
  var result = GETPROP_RESULT;
  result.plainText = plainText;
  result.prop = prevProp;
  return result;
};
var UpdateProp = function(prop, op, key, value) {
  if (op === PROP_ADD) {
    prop[key] = value;
  } else {
    if (prop.hasOwnProperty(key)) {
      delete prop[key];
    }
  }
  return prop;
};
var TagTextToProp_default = TagTextToProp;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/PropToContextStyle.js
var PropToContextStyle = function(defaultStyle, prop) {
  var result = STYLE_RESULT;
  if (!prop.hasOwnProperty("img")) {
    result.image = null;
    if (prop.hasOwnProperty("family")) {
      result.fontFamily = prop.family;
    } else {
      result.fontFamily = defaultStyle.fontFamily;
    }
    if (prop.hasOwnProperty("size")) {
      var size = prop.size;
      if (typeof size === "number") {
        size = `${size}px`;
      }
      result.fontSize = size;
    } else {
      result.fontSize = defaultStyle.fontSize;
    }
    result.fontStyle = GetFontStyle(prop);
    if (prop.hasOwnProperty("color")) {
      result.color = prop.color;
    } else {
      result.color = defaultStyle.color;
    }
    if (prop.hasOwnProperty("stroke")) {
      if (prop.stroke === true) {
        result.stroke = defaultStyle.stroke;
        result.strokeThickness = defaultStyle.strokeThickness;
      } else {
        result.stroke = prop.stroke;
        result.strokeThickness = defaultStyle.strokeThickness;
      }
    } else {
      result.stroke = defaultStyle.stroke;
      result.strokeThickness = 0;
    }
  } else {
    result.image = prop.img;
  }
  if (prop.hasOwnProperty("shadow")) {
    if (prop.shadow === true) {
      result.shadowColor = defaultStyle.shadowColor;
      result.shadowOffsetX = defaultStyle.shadowOffsetX;
      result.shadowOffsetY = defaultStyle.shadowOffsetY;
      result.shadowBlur = defaultStyle.shadowBlur;
      result.shadowStroke = true;
      result.shadowFill = true;
    } else {
      result.shadowColor = prop.shadow;
      result.shadowOffsetX = defaultStyle.shadowOffsetX;
      result.shadowOffsetY = defaultStyle.shadowOffsetY;
      result.shadowBlur = defaultStyle.shadowBlur;
      result.shadowStroke = true;
      result.shadowFill = true;
    }
  } else {
    result.shadowColor = "#000";
    result.shadowOffsetX = 0;
    result.shadowOffsetY = 0;
    result.shadowBlur = 0;
    result.shadowStroke = false;
    result.shadowFill = false;
  }
  if (prop.hasOwnProperty("u")) {
    if (prop.u === true) {
      result.underlineColor = defaultStyle.underlineColor;
      result.underlineThickness = defaultStyle.underlineThickness;
      result.underlineOffset = defaultStyle.underlineOffset;
    } else {
      result.underlineColor = prop.u;
      result.underlineThickness = defaultStyle.underlineThickness;
      result.underlineOffset = defaultStyle.underlineOffset;
    }
  } else {
    result.underlineColor = "#000";
    result.underlineThickness = 0;
    result.underlineOffset = 0;
  }
  if (prop.hasOwnProperty("s")) {
    if (prop.s === true) {
      result.strikethroughColor = defaultStyle.strikethroughColor;
      result.strikethroughThickness = defaultStyle.strikethroughThickness;
      result.strikethroughOffset = defaultStyle.strikethroughOffset;
    } else {
      result.strikethroughColor = prop.s;
      result.strikethroughThickness = defaultStyle.strikethroughThickness;
      result.strikethroughOffset = defaultStyle.strikethroughOffset;
    }
  } else {
    result.strikethroughColor = "#000";
    result.strikethroughThickness = 0;
    result.strikethroughOffset = 0;
  }
  return result;
};
var GetFontStyle = function(prop) {
  var isBold = prop.b;
  var weight = prop.weight;
  var isItalic = prop.i;
  if (isBold || weight || isItalic) {
    if (isItalic) {
      if (isBold) {
        return "bold italic";
      } else if (weight) {
        return `${weight} italic`;
      } else {
        return "italic";
      }
    } else {
      if (isBold) {
        return "bold";
      } else {
        return weight.toString();
      }
    }
  } else {
    return "";
  }
};
var STYLE_RESULT = new TextStyle_default();
var PropToContextStyle_default = PropToContextStyle;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/PropToTagText.js
var PropToTagText = function(text, prop, prevProp) {
  if (prevProp == null) {
    prevProp = EMPTYPROP;
  }
  var delimiterLeft = this.delimiters[0];
  var delimiterRight = this.delimiters[1];
  var headers = [];
  for (var k in prevProp) {
    if (!prop.hasOwnProperty(k)) {
      headers.push(`${delimiterLeft}/${k}${delimiterRight}`);
    }
  }
  for (var k in prop) {
    var value = prop[k];
    if (k === "img") {
    } else {
      if (prevProp[k] === value) {
        continue;
      }
    }
    switch (k) {
      case "size":
        headers.push(`${delimiterLeft}size=${value.replace("px", "")}${delimiterRight}`);
        break;
      case "color":
      case "weight":
      case "stroke":
      case "y":
      case "img":
      case "area":
      case "url":
      case "align":
      case "id":
        headers.push(`${delimiterLeft}${k}=${value}${delimiterRight}`);
        break;
      case "u":
      case "s":
        if (value === true) {
          headers.push(`${delimiterLeft}${k}${delimiterRight}`);
        } else {
          headers.push(`${delimiterLeft}${k}=${value}${delimiterRight}`);
        }
        break;
      default:
        headers.push(`${delimiterLeft}${k}${delimiterRight}`);
        break;
    }
  }
  headers.push(text);
  return headers.join("");
};
var EMPTYPROP = {};
var PropToTagText_default = PropToTagText;

// node_modules/phaser3-rex-plugins/plugins/utils/string/EscapeRegex.js
var EscapeRegex = function(s) {
  return s.replace(re0, "\\$&").replace(re1, "\\x2d");
};
var re0 = /[|\\{}()[\]^$+*?.]/g;
var re1 = /-/g;
var EscapeRegex_default = EscapeRegex;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/TagRegex.js
var DelimiterLeftSave;
var DelimiterRightSave;
var TagRegexSave = {};
var GetOpenTagRegString = function(delimiterLeft, delimiterRight, tagName, param) {
  if (param === void 0) {
    return `${delimiterLeft}${tagName}${delimiterRight}`;
  } else {
    return `${delimiterLeft}${tagName}=(${param})${delimiterRight}`;
  }
};
var GetCloseTagRegString = function(delimiterLeft, delimiterRight, tagName) {
  return `${delimiterLeft}/${tagName}${delimiterRight}`;
};
var GenerateStringRegEx = function(delimiterRight) {
  return `[^${delimiterRight}]+`;
};
var NUMBER_PARAM = "[-.0-9]+";
var colorParameterList = [
  "[a-zA-Z]+",
  "#[0-9abcdef]+",
  "rgba?\\(s*[.0-9]+s*(,s*[.0-9]+s*){2,3}\\)"
];
var COLOR_PARAM = colorParameterList.join("|");
var SetDelimiters = function(delimiterLeft, delimiterRight) {
  if (delimiterRight === void 0) {
    var delimeters = delimiterLeft;
    delimiterLeft = delimeters[0];
    delimiterRight = delimeters[1];
  }
  if (DelimiterLeftSave === delimiterLeft && DelimiterRightSave === delimiterRight) {
    return false;
  }
  DelimiterLeftSave = delimiterLeft;
  DelimiterRightSave = delimiterRight;
  delimiterLeft = EscapeRegex_default(delimiterLeft);
  delimiterRight = EscapeRegex_default(delimiterRight);
  var STR_PARAM = GenerateStringRegEx(delimiterRight);
  var ESC = "esc";
  var ESC_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ESC);
  var ESC_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ESC);
  var RAW = "raw";
  var RAW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, RAW);
  var RAW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, RAW);
  var BLOD = "b";
  var BLOD_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, BLOD);
  var BLOD_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, BLOD);
  var ITALICS = "i";
  var ITALICS_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ITALICS);
  var ITALICS_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ITALICS);
  var WEIGHT = "weight";
  var WEIGHT_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, WEIGHT, NUMBER_PARAM);
  var WEIGHT_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, WEIGHT);
  var SIZE = "size";
  var SIZE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SIZE, NUMBER_PARAM);
  var SIZE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SIZE);
  var COLOR = "color";
  var COLOR_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, COLOR, COLOR_PARAM);
  var COLOR_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, COLOR);
  var UNDERLINE = "u";
  var UNDERLINE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
  var UNDERLINE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, UNDERLINE, COLOR_PARAM);
  var UNDERLINE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, UNDERLINE);
  var STRIKETHROUGH = "s";
  var STRIKETHROUGH_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
  var STRIKETHROUGH_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH, COLOR_PARAM);
  var STRIKETHROUGH_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STRIKETHROUGH);
  var SHADOW = "shadow";
  var SHADOW_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW);
  var SHADOW_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, SHADOW, COLOR_PARAM);
  var SHADOW_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, SHADOW);
  var STROKE = "stroke";
  var STROKE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE);
  var STROKE_OPENC = GetOpenTagRegString(delimiterLeft, delimiterRight, STROKE, COLOR_PARAM);
  var STROKE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, STROKE);
  var OFFSETY = "y";
  var OFFSETY_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, OFFSETY, NUMBER_PARAM);
  var OFFSETY_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, OFFSETY);
  var IMAGE = "img";
  var IMAGE_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, IMAGE, STR_PARAM);
  var IMAGE_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, IMAGE);
  var AREA = "area";
  var AREA_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, AREA, STR_PARAM);
  var AREA_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, AREA);
  var URL = "url";
  var URL_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, URL, STR_PARAM);
  var URL_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, URL);
  var ALIGN = "align";
  var ALIGN_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ALIGN, STR_PARAM);
  var ALIGN_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ALIGN);
  var ID = "id";
  var ID_OPEN = GetOpenTagRegString(delimiterLeft, delimiterRight, ID, STR_PARAM);
  var ID_CLOSE = GetCloseTagRegString(delimiterLeft, delimiterRight, ID);
  TagRegexSave.RE_ESC_OPEN = new RegExp(ESC_OPEN, "i");
  TagRegexSave.RE_ESC_CLOSE = new RegExp(ESC_CLOSE, "i");
  TagRegexSave.RE_RAW_OPEN = new RegExp(RAW_OPEN, "i");
  TagRegexSave.RE_RAW_CLOSE = new RegExp(RAW_CLOSE, "i");
  TagRegexSave.RE_BLOD_OPEN = new RegExp(BLOD_OPEN, "i");
  TagRegexSave.RE_BLOD_CLOSE = new RegExp(BLOD_CLOSE, "i");
  TagRegexSave.RE_ITALICS_OPEN = new RegExp(ITALICS_OPEN, "i");
  TagRegexSave.RE_ITALICS_CLOSE = new RegExp(ITALICS_CLOSE, "i");
  TagRegexSave.RE_WEIGHT_OPEN = new RegExp(WEIGHT_OPEN, "i");
  TagRegexSave.RE_WEIGHT_CLOSE = new RegExp(WEIGHT_CLOSE, "i");
  TagRegexSave.RE_SIZE_OPEN = new RegExp(SIZE_OPEN, "i");
  TagRegexSave.RE_SIZE_CLOSE = new RegExp(SIZE_CLOSE, "i");
  TagRegexSave.RE_COLOR_OPEN = new RegExp(COLOR_OPEN, "i");
  TagRegexSave.RE_COLOR_CLOSE = new RegExp(COLOR_CLOSE, "i");
  TagRegexSave.RE_UNDERLINE_OPEN = new RegExp(UNDERLINE_OPEN, "i");
  TagRegexSave.RE_UNDERLINE_OPENC = new RegExp(UNDERLINE_OPENC, "i");
  TagRegexSave.RE_UNDERLINE_CLOSE = new RegExp(UNDERLINE_CLOSE, "i");
  TagRegexSave.RE_STRIKETHROUGH_OPEN = new RegExp(STRIKETHROUGH_OPEN, "i");
  TagRegexSave.RE_STRIKETHROUGH_OPENC = new RegExp(STRIKETHROUGH_OPENC, "i");
  TagRegexSave.RE_STRIKETHROUGH_CLOSE = new RegExp(STRIKETHROUGH_CLOSE, "i");
  TagRegexSave.RE_SHADOW_OPEN = new RegExp(SHADOW_OPEN, "i");
  TagRegexSave.RE_SHADOW_OPENC = new RegExp(SHADOW_OPENC, "i");
  TagRegexSave.RE_SHADOW_CLOSE = new RegExp(SHADOW_CLOSE, "i");
  TagRegexSave.RE_STROKE_OPEN = new RegExp(STROKE_OPEN, "i");
  TagRegexSave.RE_STROKE_OPENC = new RegExp(STROKE_OPENC, "i");
  TagRegexSave.RE_STROKE_CLOSE = new RegExp(STROKE_CLOSE, "i");
  TagRegexSave.RE_OFFSETY_OPEN = new RegExp(OFFSETY_OPEN, "i");
  TagRegexSave.RE_OFFSETY_CLOSE = new RegExp(OFFSETY_CLOSE, "i");
  TagRegexSave.RE_IMAGE_OPEN = new RegExp(IMAGE_OPEN, "i");
  TagRegexSave.RE_IMAGE_CLOSE = new RegExp(IMAGE_CLOSE, "i");
  TagRegexSave.RE_AREA_OPEN = new RegExp(AREA_OPEN, "i");
  TagRegexSave.RE_AREA_CLOSE = new RegExp(AREA_CLOSE, "i");
  TagRegexSave.RE_URL_OPEN = new RegExp(URL_OPEN, "i");
  TagRegexSave.RE_URL_CLOSE = new RegExp(URL_CLOSE, "i");
  TagRegexSave.RE_ALIGN_OPEN = new RegExp(ALIGN_OPEN, "i");
  TagRegexSave.RE_ALIGN_CLOSE = new RegExp(ALIGN_CLOSE, "i");
  TagRegexSave.RE_ID_OPEN = new RegExp(ID_OPEN, "i");
  TagRegexSave.RE_ID_CLOSE = new RegExp(ID_CLOSE, "i");
  TagRegexSave.RE_SPLITTEXT = new RegExp([
    RAW_OPEN,
    RAW_CLOSE,
    ESC_OPEN,
    ESC_CLOSE,
    BLOD_OPEN,
    BLOD_CLOSE,
    ITALICS_OPEN,
    ITALICS_CLOSE,
    WEIGHT_OPEN,
    WEIGHT_CLOSE,
    SIZE_OPEN,
    SIZE_CLOSE,
    COLOR_OPEN,
    COLOR_CLOSE,
    UNDERLINE_OPEN,
    UNDERLINE_OPENC,
    UNDERLINE_CLOSE,
    STRIKETHROUGH_OPEN,
    STRIKETHROUGH_OPENC,
    STRIKETHROUGH_CLOSE,
    SHADOW_OPEN,
    SHADOW_OPENC,
    SHADOW_CLOSE,
    STROKE_OPEN,
    STROKE_OPENC,
    STROKE_CLOSE,
    OFFSETY_OPEN,
    OFFSETY_CLOSE,
    IMAGE_OPEN,
    IMAGE_CLOSE,
    AREA_OPEN,
    AREA_CLOSE,
    URL_OPEN,
    URL_CLOSE,
    ALIGN_OPEN,
    ALIGN_CLOSE,
    ID_OPEN,
    ID_CLOSE
  ].join("|"), "ig");
  return true;
};
var GetTagRegex = function(delimiterLeft, delimiterRight) {
  if (delimiterLeft !== void 0) {
    SetDelimiters(delimiterLeft, delimiterRight);
  }
  return Object.assign({}, TagRegexSave);
};

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/parser/Parser.js
var GetValue7 = Phaser.Utils.Objects.GetValue;
var Parser = class {
  constructor(style) {
    var delimiters = GetValue7(style, "delimiters", "[]");
    this.tagRegex = GetTagRegex(delimiters);
    this.delimiters = delimiters;
  }
  getStrokeThinkness(defaultStyle, prop) {
    var strokeThickness;
    if (prop.hasOwnProperty("stroke")) {
      strokeThickness = defaultStyle.strokeThickness;
    } else {
      strokeThickness = 0;
    }
    return strokeThickness;
  }
  setDelimiters(delimiterLeft, delimiterRight) {
    if (SetDelimiters(delimiterLeft, delimiterRight)) {
      this.tagRegex = GetTagRegex();
    }
    return this;
  }
};
var methods4 = {
  splitText: SplitText_default,
  tagTextToProp: TagTextToProp_default,
  propToContextStyle: PropToContextStyle_default,
  propToTagText: PropToTagText_default
};
Object.assign(
  Parser.prototype,
  methods4
);
var Parser_default = Parser;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/BBCodeText.js
var BBCodeText = class extends Text_default {
  constructor(scene, x, y, text, style) {
    var parser = new Parser_default(style);
    super(scene, x, y, text, style, "rexBBCodeText", parser);
  }
  setDelimiters(delimiterLeft, delimiterRight) {
    this.parse.setDelimiters(delimiterLeft, delimiterRight);
    return this;
  }
};
var BBCodeText_default = BBCodeText;

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/Factory.js
function Factory_default(x, y, text, style) {
  var gameObject = new BBCodeText_default(this.scene, x, y, text, style);
  this.scene.add.existing(gameObject);
  return gameObject;
}

// node_modules/phaser3-rex-plugins/plugins/gameobjects/tagtext/bbcodetext/Creator.js
var GetAdvancedValue2 = Phaser.Utils.Objects.GetAdvancedValue;
var BuildGameObject = Phaser.GameObjects.BuildGameObject;
function Creator_default(config, addToScene) {
  if (config === void 0) {
    config = {};
  }
  if (addToScene !== void 0) {
    config.add = addToScene;
  }
  var content = GetAdvancedValue2(config, "text", "");
  var style = GetAdvancedValue2(config, "style", null);
  var padding = GetAdvancedValue2(config, "padding", null);
  if (padding !== null) {
    style.padding = padding;
  }
  var gameObject = new BBCodeText_default(this.scene, 0, 0, content, style);
  BuildGameObject(this.scene, gameObject, config);
  gameObject.autoRound = GetAdvancedValue2(config, "autoRound", true);
  return gameObject;
}

// node_modules/phaser3-rex-plugins/plugins/utils/object/SetValue.js
var IsInValidKey = function(keys) {
  return keys == null || keys === "" || keys.length === 0;
};
var GetEntry = function(target, keys, defaultEntry) {
  var entry = target;
  if (IsInValidKey(keys)) {
  } else {
    if (typeof keys === "string") {
      keys = keys.split(".");
    }
    var key;
    for (var i = 0, cnt = keys.length; i < cnt; i++) {
      key = keys[i];
      if (entry[key] == null || typeof entry[key] !== "object") {
        var newEntry;
        if (i === cnt - 1) {
          if (defaultEntry === void 0) {
            newEntry = {};
          } else {
            newEntry = defaultEntry;
          }
        } else {
          newEntry = {};
        }
        entry[key] = newEntry;
      }
      entry = entry[key];
    }
  }
  return entry;
};
var SetValue = function(target, keys, value, delimiter) {
  if (delimiter === void 0) {
    delimiter = ".";
  }
  if (typeof target !== "object") {
    return;
  } else if (IsInValidKey(keys)) {
    if (value == null) {
      return;
    } else if (typeof value === "object") {
      target = value;
    }
  } else {
    if (typeof keys === "string") {
      keys = keys.split(delimiter);
    }
    var lastKey = keys.pop();
    var entry = GetEntry(target, keys);
    entry[lastKey] = value;
  }
  return target;
};
var SetValue_default = SetValue;

// node_modules/phaser3-rex-plugins/plugins/bbcodetext-plugin.js
var BBCodeTextPlugin = class extends Phaser.Plugins.BasePlugin {
  constructor(pluginManager) {
    super(pluginManager);
    pluginManager.registerGameObject("rexBBCodeText", Factory_default, Creator_default);
  }
  start() {
    var eventEmitter = this.game.events;
    eventEmitter.on("destroy", this.destroy, this);
  }
};
SetValue_default(window, "RexPlugins.GameObjects.BBCodeText", BBCodeText_default);
var bbcodetext_plugin_default = BBCodeTextPlugin;
export {
  bbcodetext_plugin_default as default
};
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
//# sourceMappingURL=phaser3-rex-plugins_plugins_bbcodetext-plugin__js.js.map
